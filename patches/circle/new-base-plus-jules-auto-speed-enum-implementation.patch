diff --git a/lib/usb/dwhcidevice.cpp b/lib/usb/dwhcidevice.cpp
index f501ce1c..52be187d 100644
--- a/lib/usb/dwhcidevice.cpp
+++ b/lib/usb/dwhcidevice.cpp
@@ -2,7 +2,7 @@
 // dwhcidevice.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2014-2025  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2014-2025  R. Stange <rsta2@gmx.net>
 // 
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -151,7 +151,8 @@ boolean CDWHCIDevice::Initialize (boolean bScanDevices)
 	assert (m_pTimer != 0);
 
 	CDWHCIRegister VendorId (DWHCI_CORE_VENDOR_ID);
-	if (VendorId.Read () != 0x4F54280A)
+	if (   VendorId.Read () != 0x4F54280A
+	    && VendorId.Get ()  != 0x4F54294A)		// QEMU
 	{
 		LOGERR ("Unknown vendor 0x%0X", VendorId.Get ());
 		return FALSE;
diff --git a/lib/usb/gadget/dwusbgadget.cpp b/lib/usb/gadget/dwusbgadget.cpp
index dc3f93cd..845594b8 100644
--- a/lib/usb/gadget/dwusbgadget.cpp
+++ b/lib/usb/gadget/dwusbgadget.cpp
@@ -506,14 +506,24 @@ void CDWUSBGadget::HandleUSBSuspend (void)
 	LOGDBG ("USB suspend");
 #endif
 
-	m_bPnPEvent[PnPEventSuspend] = TRUE;
-
-	for (unsigned i = 0; i <= NumberOfEPs; i++)
+	if (   m_State != StatePowered
+	    && m_State != StateSuspended)
 	{
-		if (m_pEP[i])
+		m_bPnPEvent[PnPEventSuspend] = TRUE;
+
+		for (unsigned i = 0; i <= NumberOfEPs; i++)
 		{
-			m_pEP[i]->OnSuspend ();
+			if (m_pEP[i])
+			{
+				m_pEP[i]->OnSuspend ();
+			}
 		}
+
+		// Disable all interrupts
+		CDWHCIRegister AHBConfig (DWHCI_CORE_AHB_CFG);
+		AHBConfig.Read ();
+		AHBConfig.And (~DWHCI_CORE_AHB_CFG_GLOBALINT_MASK);
+		AHBConfig.Write ();
 	}
 
 	CDWHCIRegister IntStatus (DWHCI_CORE_INT_STAT, DWHCI_CORE_INT_MASK_USB_SUSPEND);
@@ -526,6 +536,21 @@ void CDWUSBGadget::HandleUSBReset (void)
 	LOGDBG ("USB reset");
 #endif
 
+	switch (m_State)
+	{
+	case StateConfigured:
+		SetConfiguration (0);
+		// fall through
+
+	case StateEnumDone:
+		assert (m_pEP[0]);
+		m_pEP[0]->OnDeactivate ();
+		break;
+
+	default:
+		break;
+	}
+
 	// Set NAK for all OUT EPs
 	for (unsigned i = 0; i <= NumberOfOutEPs; i++)
 	{
@@ -607,6 +632,9 @@ void CDWUSBGadget::HandleEnumerationDone (void)
 		USBConfig.Or (9 << DWHCI_CORE_USB_CFG_TURNAROUND_TIME__SHIFT);
 		USBConfig.Write ();
 
+		TDeviceSpeed Speed = GetNegotiatedUSBSpeed ();
+		OnNegotiatedSpeed (Speed);
+
 		assert (m_pEP[0]);
 		m_pEP[0]->OnActivate ();
 
@@ -649,7 +677,8 @@ void CDWUSBGadget::HandleOutEPInterrupt (void)
 	LOGDBG ("Out EP interrupt");
 #endif
 
-	assert (   m_State == StateEnumDone
+	assert (   m_State == StateSuspended
+		|| m_State == StateEnumDone
 		|| m_State == StateConfigured);
 
 	CDWHCIRegister AllEPsIntStat (DWHCI_DEV_ALL_EPS_INT_STAT);
@@ -660,9 +689,19 @@ void CDWUSBGadget::HandleOutEPInterrupt (void)
 	{
 		if (nOutEPStat & 1)
 		{
-			assert (nEP <= NumberOfEPs);
-			assert (m_pEP[nEP]);
-			m_pEP[nEP]->HandleOutInterrupt ();
+			if (m_State != StateSuspended)
+			{
+				assert (nEP <= NumberOfEPs);
+				assert (m_pEP[nEP]);
+				m_pEP[nEP]->HandleOutInterrupt ();
+			}
+			else
+			{
+				CDWHCIRegister OutEPIntAck (DWHCI_DEV_OUT_EP_INT (nEP));
+				OutEPIntAck.Set (  DWHCI_DEV_OUT_EP_INT_SETUP_DONE
+						 | DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE);
+				OutEPIntAck.Write ();
+			}
 		}
 	}
 }
@@ -676,12 +715,14 @@ void CDWUSBGadget::InterruptHandler (void)
 	u32 nIntStatus = IntStatus.Read () & IntMask.Read ();
 
 #ifdef USB_GADGET_DEBUG
-	LOGDBG ("IRQ (status 0x%08X)", nIntStatus);
+	LOGDBG ("IRQ (status 0x%08X, state %u)", nIntStatus, (unsigned) m_State);
 #endif
 
 	if (nIntStatus & DWHCI_CORE_INT_MASK_USB_SUSPEND)
 	{
 		HandleUSBSuspend ();
+
+		nIntStatus = 0;
 	}
 
 	if (nIntStatus & DWHCI_CORE_INT_MASK_USB_RESET_INTR)
@@ -752,6 +793,26 @@ void CDWUSBGadget::SetDeviceAddress (u8 uchAddress)
 
 boolean CDWUSBGadget::SetConfiguration (u8 uchConfiguration)
 {
+	if (uchConfiguration == 0)
+	{
+		if (m_State == StateEnumDone)
+		{
+			return TRUE;
+		}
+
+		m_State = StateEnumDone;
+
+		for (unsigned i = 1; i <= NumberOfEPs; i++)
+		{
+			if (m_pEP[i])
+			{
+				m_pEP[i]->OnDeactivate ();
+			}
+		}
+
+		return TRUE;
+	}
+
 	if (uchConfiguration != 1)
 	{
 		return FALSE;
@@ -782,3 +843,22 @@ boolean CDWUSBGadget::SetConfiguration (u8 uchConfiguration)
 
 	return TRUE;
 }
+
+CDWUSBGadget::TDeviceSpeed CDWUSBGadget::GetNegotiatedUSBSpeed (void) const
+{
+	CDWHCIRegister DeviceStatus (DWHCI_DEV_STS);
+	u32 nEnumSpeed = (DeviceStatus.Read () & DWHCI_DEV_STS_ENUM_SPEED__MASK) >> DWHCI_DEV_STS_ENUM_SPEED__SHIFT;
+
+	switch (nEnumSpeed)
+	{
+	case DWHCI_DEV_STS_ENUM_SPEED_HS_30_60:
+		return HighSpeed;
+
+	case DWHCI_DEV_STS_ENUM_SPEED_FS_30_60:
+	case DWHCI_DEV_STS_ENUM_SPEED_FS_48:
+		return FullSpeed;
+
+	default:
+		return DeviceSpeedUnknown;
+	}
+}
diff --git a/lib/usb/gadget/dwusbgadgetendpoint.cpp b/lib/usb/gadget/dwusbgadgetendpoint.cpp
index d71abd08..3b93a816 100644
--- a/lib/usb/gadget/dwusbgadgetendpoint.cpp
+++ b/lib/usb/gadget/dwusbgadgetendpoint.cpp
@@ -2,7 +2,7 @@
 // dwusbgadgetendpoint.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -65,6 +65,22 @@ CDWUSBGadgetEndpoint::~CDWUSBGadgetEndpoint (void)
 	m_pGadget->RemoveEndpoint (m_nEP);
 }
 
+void CDWUSBGadgetEndpoint::SetMaxPacketSize (size_t nMaxPacketSize)
+{
+	m_nMaxPacketSize = nMaxPacketSize;
+
+	if (m_nEP != 0)
+	{
+		CDWHCIRegister EPCtrl (  m_Direction == DirectionIn
+				       ? DWHCI_DEV_IN_EP_CTRL (m_nEP)
+				       : DWHCI_DEV_OUT_EP_CTRL (m_nEP));
+		EPCtrl.Read ();
+		EPCtrl.And (~DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__MASK);
+		EPCtrl.Or (m_nMaxPacketSize << DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__SHIFT);
+		EPCtrl.Write ();
+	}
+}
+
 void CDWUSBGadgetEndpoint::OnUSBReset (void)
 {
 	InitTransfer ();
@@ -255,6 +271,30 @@ void CDWUSBGadgetEndpoint::BeginTransfer (TTransferMode Mode, void *pBuffer, siz
 	}
 }
 
+void CDWUSBGadgetEndpoint::CancelTransfer (void)
+{
+	if (m_TransferMode == TransferDataIn)
+	{
+		CDWHCIRegister InEPCtrl (DWHCI_DEV_IN_EP_CTRL (m_nEP), 0);
+		InEPCtrl.Read ();
+		InEPCtrl.And (~DWHCI_DEV_EP_CTRL_EP_ENABLE);
+		InEPCtrl.And (~DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+		InEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_DISABLE);
+		InEPCtrl.Write ();
+	}
+	else if (m_TransferMode != TransferUnknown)
+	{
+		CDWHCIRegister OutEPCtrl (DWHCI_DEV_OUT_EP_CTRL (m_nEP));
+		OutEPCtrl.Read ();
+		OutEPCtrl.And (~DWHCI_DEV_EP_CTRL_EP_ENABLE);
+		OutEPCtrl.And (~DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+		OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_DISABLE);
+		OutEPCtrl.Write ();
+	}
+
+	InitTransfer ();
+}
+
 size_t CDWUSBGadgetEndpoint::FinishTransfer (void)
 {
 	assert (m_TransferMode < TransferUnknown);
@@ -275,7 +315,12 @@ size_t CDWUSBGadgetEndpoint::FinishTransfer (void)
 
 	if (nXferSize)
 	{
-		debug_hexdump (m_pTransferBuffer, nXferSize, From);
+		size_t nDumpSize = nXferSize > 16 ? 16 : nXferSize;  // Max 16 bytes
+		debug_hexdump (m_pTransferBuffer, nDumpSize, From);
+		if (nXferSize > 16)
+		{
+			LOGDBG ("... (%u more bytes not shown)", nXferSize - 16);
+		}
 	}
 #endif
 
diff --git a/lib/usb/gadget/dwusbgadgetendpoint0.cpp b/lib/usb/gadget/dwusbgadgetendpoint0.cpp
index 3a70f3d3..ba825668 100644
--- a/lib/usb/gadget/dwusbgadgetendpoint0.cpp
+++ b/lib/usb/gadget/dwusbgadgetendpoint0.cpp
@@ -2,7 +2,7 @@
 // dwusbgadgetendpoint0.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -40,6 +40,13 @@ void CDWUSBGadgetEndpoint0::OnActivate (void)
 	BeginTransfer (TransferSetupOut, m_OutBuffer, sizeof (TSetupData));
 }
 
+void CDWUSBGadgetEndpoint0::OnDeactivate (void)
+{
+	m_State = StateDisconnect;
+
+	CancelTransfer ();
+}
+
 void CDWUSBGadgetEndpoint0::OnControlMessage (void)
 {
 	assert (m_pGadget);
@@ -166,15 +173,25 @@ void CDWUSBGadgetEndpoint0::OnControlMessage (void)
 		default:
 			if (pSetupData->wLength)
 			{
-				m_State = StateOutDataPhase;
-
 				// EP0 can transfer only up to 127 bytes at once. Therefore
 				// we split greater transfers into multiple transfers, with
 				// up to max. packet size each.
-				assert (pSetupData->wLength <= sizeof m_OutBuffer);
+
+				if (pSetupData->wLength > sizeof m_OutBuffer)
+				{
+					Stall (FALSE);
+
+					BeginTransfer (TransferSetupOut, m_OutBuffer,
+						       sizeof (TSetupData));
+
+					return;
+				}
+
 				m_nBytesLeft = pSetupData->wLength;
 				m_pBufPtr = m_OutBuffer;
 
+				m_State = StateOutDataPhase;
+
 				BeginTransfer (TransferDataOut, m_pBufPtr,
 						 m_nBytesLeft <= m_nMaxPacketSize
 					       ? m_nBytesLeft : m_nMaxPacketSize);
diff --git a/lib/usb/gadget/usbcdcgadget.cpp b/lib/usb/gadget/usbcdcgadget.cpp
index 26a08b34..3bd6db3e 100644
--- a/lib/usb/gadget/usbcdcgadget.cpp
+++ b/lib/usb/gadget/usbcdcgadget.cpp
@@ -21,10 +21,9 @@
 //
 #include <circle/usb/gadget/usbcdcgadget.h>
 #include <circle/usb/gadget/usbcdcgadgetendpoint.h>
-#include <circle/sysconfig.h>
 #include <assert.h>
 
-const TUSBDeviceDescriptor CUSBCDCGadget::s_DeviceDescriptor =
+TUSBDeviceDescriptor CUSBCDCGadget::s_DeviceDescriptor =
 {
 	sizeof (TUSBDeviceDescriptor),
 	DESCRIPTOR_DEVICE,
@@ -131,11 +130,13 @@ const char *const CUSBCDCGadget::s_StringDescriptor[] =
 	"CDC Gadget"
 };
 
-CUSBCDCGadget::CUSBCDCGadget (CInterruptSystem *pInterruptSystem)
+CUSBCDCGadget::CUSBCDCGadget (CInterruptSystem *pInterruptSystem, u16 usVendorID, u16 usProductID)
 :	CDWUSBGadget (pInterruptSystem, HighSpeed),
 	m_pInterface (nullptr),
 	m_pEP {nullptr, nullptr, nullptr, nullptr}
 {
+	s_DeviceDescriptor.idVendor = usVendorID;
+	s_DeviceDescriptor.idProduct = usProductID;
 }
 
 CUSBCDCGadget::~CUSBCDCGadget (void)
diff --git a/lib/usb/gadget/usbcdcgadgetendpoint.cpp b/lib/usb/gadget/usbcdcgadgetendpoint.cpp
index e0b3186a..813198b6 100644
--- a/lib/usb/gadget/usbcdcgadgetendpoint.cpp
+++ b/lib/usb/gadget/usbcdcgadgetendpoint.cpp
@@ -4,7 +4,7 @@
 // This file by Sebastien Nicolas <seba1978@gmx.de>
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -70,6 +70,14 @@ void CUSBCDCGadgetEndpoint::OnActivate (void)
 	}
 }
 
+void CUSBCDCGadgetEndpoint::OnDeactivate (void)
+{
+	if (GetDirection () == DirectionOut)
+	{
+		CancelTransfer ();
+	}
+}
+
 void CUSBCDCGadgetEndpoint::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	if (!bIn)
diff --git a/lib/usb/gadget/usbmidigadget.cpp b/lib/usb/gadget/usbmidigadget.cpp
index d0aeb133..479e1e99 100644
--- a/lib/usb/gadget/usbmidigadget.cpp
+++ b/lib/usb/gadget/usbmidigadget.cpp
@@ -19,10 +19,9 @@
 //
 #include <circle/usb/gadget/usbmidigadget.h>
 #include <circle/usb/gadget/usbmidigadgetendpoint.h>
-#include <circle/sysconfig.h>
 #include <assert.h>
 
-const TUSBDeviceDescriptor CUSBMIDIGadget::s_DeviceDescriptor =
+TUSBDeviceDescriptor CUSBMIDIGadget::s_DeviceDescriptor =
 {
 	sizeof (TUSBDeviceDescriptor),
 	DESCRIPTOR_DEVICE,
@@ -166,11 +165,13 @@ const char *const CUSBMIDIGadget::s_StringDescriptor[] =
 	"MIDI Gadget"
 };
 
-CUSBMIDIGadget::CUSBMIDIGadget (CInterruptSystem *pInterruptSystem)
+CUSBMIDIGadget::CUSBMIDIGadget (CInterruptSystem *pInterruptSystem, u16 usVendorID, u16 usProductID)
 :	CDWUSBGadget (pInterruptSystem, HighSpeed),
 	m_pInterface (nullptr),
 	m_pEP {nullptr, nullptr, nullptr}
 {
+	s_DeviceDescriptor.idVendor = usVendorID;
+	s_DeviceDescriptor.idProduct = usProductID;
 }
 
 CUSBMIDIGadget::~CUSBMIDIGadget (void)
diff --git a/lib/usb/gadget/usbmidigadgetendpoint.cpp b/lib/usb/gadget/usbmidigadgetendpoint.cpp
index 040df576..f3a17711 100644
--- a/lib/usb/gadget/usbmidigadgetendpoint.cpp
+++ b/lib/usb/gadget/usbmidigadgetendpoint.cpp
@@ -2,7 +2,7 @@
 // usbmidigadgetendpoint.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -69,6 +69,14 @@ void CUSBMIDIGadgetEndpoint::OnActivate (void)
 	}
 }
 
+void CUSBMIDIGadgetEndpoint::OnDeactivate (void)
+{
+	if (GetDirection () == DirectionOut)
+	{
+		CancelTransfer ();
+	}
+}
+
 void CUSBMIDIGadgetEndpoint::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	if (!bIn)
diff --git a/lib/usb/gadget/usbmsdgadget.cpp b/lib/usb/gadget/usbmsdgadget.cpp
index 6ec80662..42dccfc8 100644
--- a/lib/usb/gadget/usbmsdgadget.cpp
+++ b/lib/usb/gadget/usbmsdgadget.cpp
@@ -4,7 +4,7 @@
 // USB Mass Storage Gadget by Mike Messinides
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -31,7 +31,7 @@
 #define MLOGERR(From,...)		CLogger::Get ()->Write (From, LogError,__VA_ARGS__)
 #define DEFAULT_BLOCKS 16000
 
-const TUSBDeviceDescriptor CUSBMSDGadget::s_DeviceDescriptor =
+TUSBDeviceDescriptor CUSBMSDGadget::s_DeviceDescriptor =
 {
 	sizeof (TUSBDeviceDescriptor),
 	DESCRIPTOR_DEVICE,
@@ -93,11 +93,14 @@ const char *const CUSBMSDGadget::s_StringDescriptor[] =
 	"Mass Storage Gadget"
 };
 
-CUSBMSDGadget::CUSBMSDGadget (CInterruptSystem *pInterruptSystem, CDevice *pDevice)
+CUSBMSDGadget::CUSBMSDGadget (CInterruptSystem *pInterruptSystem, CDevice *pDevice,
+			      u16 usVendorID, u16 usProductID)
 :	CDWUSBGadget (pInterruptSystem, HighSpeed),
 	m_pDevice (pDevice),
 	m_pEP {nullptr, nullptr, nullptr}
 {
+	s_DeviceDescriptor.idVendor = usVendorID;
+	s_DeviceDescriptor.idProduct = usProductID;
 	if(pDevice)SetDevice(pDevice);
 }
 
@@ -252,6 +255,38 @@ int CUSBMSDGadget::OnClassOrVendorRequest (const TSetupData *pSetupData, u8 *pDa
 	return -1;
 }
 
+void CUSBMSDGadget::OnNegotiatedSpeed (TDeviceSpeed Speed)
+{
+	if (Speed == FullSpeed)
+	{
+		MLOGNOTE ("OnNegotiatedSpeed", "FullSpeed");
+
+		if (m_pEP[EPIn])
+		{
+			m_pEP[EPIn]->SetMaxPacketSize (64);
+		}
+
+		if (m_pEP[EPOut])
+		{
+			m_pEP[EPOut]->SetMaxPacketSize (64);
+		}
+	}
+	else
+	{
+		MLOGNOTE ("OnNegotiatedSpeed", "HighSpeed");
+
+		if (m_pEP[EPIn])
+		{
+			m_pEP[EPIn]->SetMaxPacketSize (512);
+		}
+
+		if (m_pEP[EPOut])
+		{
+			m_pEP[EPOut]->SetMaxPacketSize (512);
+		}
+	}
+}
+
 void CUSBMSDGadget::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	MLOGDEBUG("OnXferComplete", "state = %i, dir = %s, len=%i ",m_nState,bIn?"IN":"OUT",nLength);
@@ -371,6 +406,14 @@ void CUSBMSDGadget::OnActivate()
 	m_pEP[EPOut]->BeginTransfer(CUSBMSDGadgetEndpoint::TransferCBWOut,m_OutBuffer,SIZE_CBW);
 }
 
+void CUSBMSDGadget::OnDeactivate()
+{
+	MLOGNOTE("MSD OnDeactivate", "state = %i",m_nState);
+	m_MSDReady=false;
+	m_nState=TMSDState::Init;
+	m_pEP[EPOut]->CancelTransfer();
+}
+
 void CUSBMSDGadget::SendCSW()
 {
 	memcpy(&m_InBuffer,&m_CSW,SIZE_CSW);
diff --git a/lib/usb/gadget/usbmsdgadgetendpoint.cpp b/lib/usb/gadget/usbmsdgadgetendpoint.cpp
index 222d4de9..78d111b1 100644
--- a/lib/usb/gadget/usbmsdgadgetendpoint.cpp
+++ b/lib/usb/gadget/usbmsdgadgetendpoint.cpp
@@ -4,7 +4,7 @@
 // USB Mass Storage Gadget by Mike Messinides
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -50,6 +50,14 @@ void CUSBMSDGadgetEndpoint::OnActivate (void)
 	}
 }
 
+void CUSBMSDGadgetEndpoint::OnDeactivate (void)
+{
+	if (GetDirection () == DirectionOut)
+	{
+		m_pGadget->OnDeactivate();
+	}
+}
+
 void CUSBMSDGadgetEndpoint::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	MLOGNOTE("MSDEndpoint","Transfer complete nlen= %i",nLength);
@@ -77,6 +85,11 @@ void CUSBMSDGadgetEndpoint::BeginTransfer (TMSDTransferMode Mode, void *pBuffer,
 	}
 }
 
+void CUSBMSDGadgetEndpoint::CancelTransfer (void)
+{
+	CDWUSBGadgetEndpoint::CancelTransfer();
+}
+
 void CUSBMSDGadgetEndpoint::StallRequest(boolean bIn)
 {
 	CDWUSBGadgetEndpoint::Stall(bIn);
diff --git a/lib/usb/usbcdcethernet.cpp b/lib/usb/usbcdcethernet.cpp
index 5144e37c..88b3a352 100644
--- a/lib/usb/usbcdcethernet.cpp
+++ b/lib/usb/usbcdcethernet.cpp
@@ -23,6 +23,7 @@
 #include <circle/usb/usb.h>
 #include <circle/logger.h>
 #include <circle/macros.h>
+#include <circle/util.h>
 #include <assert.h>
 
 #define SET_ETHERNET_PACKET_FILTER		0x43
@@ -52,7 +53,9 @@ CUSBCDCEthernetDevice::CUSBCDCEthernetDevice (CUSBFunction *pFunction)
 	m_iMACAddress (GetMACAddressStringIndex ()),
 	m_bInterfaceOK (SelectInterfaceByClass (10, 0, 0, 2)),
 	m_pEndpointBulkIn (0),
-	m_pEndpointBulkOut (0)
+	m_pEndpointBulkOut (0),
+	m_pURB (0),
+	m_nRxLength (0)
 {
 }
 
@@ -153,27 +156,55 @@ boolean CUSBCDCEthernetDevice::SendFrame (const void *pBuffer, unsigned nLength)
 
 boolean CUSBCDCEthernetDevice::ReceiveFrame (void *pBuffer, unsigned *pResultLength)
 {
-	assert (m_pEndpointBulkIn != 0);
-	assert (pBuffer != 0);
-	CUSBRequest URB (m_pEndpointBulkIn, pBuffer, FRAME_BUFFER_SIZE);
+	boolean bResult = FALSE;
+
+	if (m_nRxLength != 0)
+	{
+		assert (pBuffer != 0);
+		assert (m_nRxLength <= FRAME_BUFFER_SIZE);
+		memcpy (pBuffer, m_RxBuffer, m_nRxLength);
 
-	URB.SetCompleteOnNAK ();
+		assert (pResultLength != 0);
+		*pResultLength = m_nRxLength;
 
-	if (!GetHost ()->SubmitBlockingRequest (&URB))
+		m_nRxLength = 0;
+
+		bResult = TRUE;
+	}
+
+	if (m_pURB == 0)
 	{
-		return FALSE;
+		assert (m_pEndpointBulkIn != 0);
+		m_pURB = new CUSBRequest (m_pEndpointBulkIn, m_RxBuffer, FRAME_BUFFER_SIZE);
+		assert (m_pURB != 0);
+
+		m_pURB->SetCompletionRoutine (CompletionRoutine, 0, this);
+
+		m_pURB->SetCompleteOnNAK ();
+
+		GetHost ()->SubmitAsyncRequest (m_pURB);
 	}
 
-	u32 nResultLength = URB.GetResultLength ();
-	if (nResultLength == 0)
+	return bResult;
+}
+
+void CUSBCDCEthernetDevice::CompletionRoutine (CUSBRequest *pURB, void *pParam, void *pContext)
+{
+	CUSBCDCEthernetDevice *pThis = (CUSBCDCEthernetDevice *) pContext;
+	assert (pThis != 0);
+
+	assert (pThis->m_pURB == pURB);
+
+	if (pURB->GetStatus () != 0)
 	{
-		return FALSE;
+		assert (pThis->m_nRxLength == 0);
+		pThis->m_nRxLength = pURB->GetResultLength ();
+		assert (pThis->m_nRxLength <= FRAME_BUFFER_SIZE);
 	}
 
-	assert (pResultLength != 0);
-	*pResultLength = nResultLength;
+	delete pURB;
 
-	return TRUE;
+	pThis->m_pURB = 0;
 }
 
 boolean CUSBCDCEthernetDevice::SetMulticastFilter (const u8 Groups[][MAC_ADDRESS_SIZE])
diff --git a/lib/usb/usbdevicefactory.cpp b/lib/usb/usbdevicefactory.cpp
index 099f8a98..75210581 100644
--- a/lib/usb/usbdevicefactory.cpp
+++ b/lib/usb/usbdevicefactory.cpp
@@ -2,7 +2,7 @@
 // usbdevicefactory.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2014-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2014-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -173,7 +173,8 @@ CUSBFunction *CUSBDeviceFactory::GetDevice (CUSBFunction *pParent, CString *pNam
 #endif
 #ifndef EXCLUDE_USB_MIDI
 	else if (   pName->Compare ("int1-3-0") == 0
-		 || pName->Compare ("ven582-12a") == 0)		// Roland UM-ONE MIDI interface
+		 || pName->Compare ("ven582-12a") == 0		// Roland UM-ONE MIDI interface
+		 || pName->Compare ("ven582-28c") == 0)		// Roland JD-08
 	{
 		pResult = new CUSBMIDIHostDevice (pParent);
 	}
diff --git a/lib/usb/usbmidihost.cpp b/lib/usb/usbmidihost.cpp
index 1d1f19b5..75f7e542 100644
--- a/lib/usb/usbmidihost.cpp
+++ b/lib/usb/usbmidihost.cpp
@@ -5,7 +5,7 @@
 // 	Copyright (C) 2016  J. Otto <joshua.t.otto@gmail.com>
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2017-2023  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2017-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -43,6 +43,18 @@ CUSBMIDIHostDevice::CUSBMIDIHostDevice (CUSBFunction *pFunction)
 	m_pPacketBuffer (0),
 	m_hTimer (0)
 {
+	const TUSBDeviceDescriptor *pDeviceDesc = GetDevice ()->GetDeviceDescriptor ();
+	assert (pDeviceDesc != 0);
+
+	// special handling for Roland JD-08
+	if (   pDeviceDesc->idVendor  == 0x0582
+	    && pDeviceDesc->idProduct == 0x028C)
+	{
+		if (!SelectInterfaceByClass (255, 3, 0))
+		{
+			CLogger::Get ()->Write (FromMIDI, LogError, "Cannot select interface");
+		}
+	}
 }
 
 CUSBMIDIHostDevice::~CUSBMIDIHostDevice (void)
@@ -75,11 +87,12 @@ boolean CUSBMIDIHostDevice::Configure (void)
 		return FALSE;
 	}
 
-	// special handling for Roland UM-ONE MIDI interface
+	// special handling for Roland UM-ONE and JD-08
 	const TUSBDeviceDescriptor *pDeviceDesc = GetDevice ()->GetDeviceDescriptor ();
 	assert (pDeviceDesc != 0);
-	boolean bIsRolandUMOne =    pDeviceDesc->idVendor  == 0x0582
-				 && pDeviceDesc->idProduct == 0x012A;
+	boolean bIsRoland =    pDeviceDesc->idVendor == 0x0582
+			    && (   pDeviceDesc->idProduct == 0x012A
+			        || pDeviceDesc->idProduct == 0x028C);
 
 	// Our strategy for now is simple: we'll take the first MIDI streaming
 	// bulk-in endpoint on this interface we can find.  To distinguish
@@ -96,7 +109,7 @@ boolean CUSBMIDIHostDevice::Configure (void)
 			continue;
 		}
 
-		if (!bIsRolandUMOne)
+		if (!bIsRoland)
 		{
 			TUSBMIDIStreamingEndpointDescriptor *pMIDIDesc =
 				(TUSBMIDIStreamingEndpointDescriptor *) GetDescriptor (DESCRIPTOR_CS_ENDPOINT);
