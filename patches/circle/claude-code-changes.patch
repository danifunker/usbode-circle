diff --git a/include/circle/usb/dwhci.h b/include/circle/usb/dwhci.h
index b094a37a..90641837 100644
--- a/include/circle/usb/dwhci.h
+++ b/include/circle/usb/dwhci.h
@@ -255,6 +255,13 @@
 	#define DWHCI_DEV_CTRL_SET_GLOBAL_OUT_NAK		(1 << 9)
 	#define DWHCI_DEV_CTRL_CLEAR_GLOBAL_OUT_NAK		(1 << 10)
 	#define DWHCI_DEV_CTRL_NAK_ON_BABBLE			(1 << 16)
+#define DWHCI_DEV_STS					(ARM_USB_DEV_BASE + 0x008)
+	#define DWHCI_DEV_STS_ENUM_SPEED__SHIFT			1
+	#define DWHCI_DEV_STS_ENUM_SPEED__MASK			(3 << 1)
+		#define DWHCI_DEV_STS_ENUM_SPEED_HS_30_60	0
+		#define DWHCI_DEV_STS_ENUM_SPEED_FS_30_60	1
+		#define DWHCI_DEV_STS_ENUM_SPEED_LS		2
+		#define DWHCI_DEV_STS_ENUM_SPEED_FS_48		3
 #define DWHCI_DEV_IN_EP_COMMON_INT_MASK			(ARM_USB_DEV_BASE + 0x010)
 	#define DWHCI_DEV_IN_EP_COMMON_INT_MASK_FIFO_UNDERRUN	(1 << 10)
 #define DWHCI_DEV_OUT_EP_COMMON_INT_MASK		(ARM_USB_DEV_BASE + 0x014)
@@ -363,7 +370,7 @@
 #define DWHCI_DEV_OUT_EP_XFER_SIZ(ep)			(ARM_USB_DEV_BASE + 0x310 + (ep)*0x20)
 	// see: DWHCI_DEV_IN_EP_XFER_SIZ(ep)
 #define DWHCI_DEV_OUT_EP_DMA_ADDR(ep)			(ARM_USB_DEV_BASE + 0x314 + (ep)*0x20)
-
+#define DWHCI_DEV_CTRL_CLEAR_GLOBAL_NON_PER_IN_NAK  (1 << 8)
 //
 // Data FIFOs (non-DMA mode only)
 //
diff --git a/include/circle/usb/gadget/dwusbgadget.h b/include/circle/usb/gadget/dwusbgadget.h
index 1c9cbf43..64f7d288 100644
--- a/include/circle/usb/gadget/dwusbgadget.h
+++ b/include/circle/usb/gadget/dwusbgadget.h
@@ -33,7 +33,8 @@ public:
 	enum TDeviceSpeed
 	{
 		FullSpeed,
-		HighSpeed
+		HighSpeed,
+		DeviceSpeedUnknown
 	};
 
 public:
@@ -64,6 +65,15 @@ public:
 	/// \brief Create application interface device (API)
 	virtual void CreateDevice (void) = 0;
 
+	/// \brief Get negotiated USB speed
+	/// \return Negotiated speed (FullSpeed or HighSpeed) or DeviceSpeedUnknown
+	TDeviceSpeed GetNegotiatedUSBSpeed (void) const;
+
+	/// \brief A new speed has been negotiated
+	/// \param Speed Negotiated speed (FullSpeed or HighSpeed)
+	/// \note May override this to update EP parameters.
+	virtual void OnNegotiatedSpeed (TDeviceSpeed Speed) {}
+
 	/// \brief Device connection has been suspended / removed
 	/// \note Have to undo AddEndpoints() and CreateDevice() here.
 	virtual void OnSuspend (void) = 0;
@@ -79,7 +89,8 @@ private:
 	boolean PowerOn (void);
 	boolean InitCore (void);
 	void InitCoreDevice (void);
-
+	void InitializeEP0 (void);
+	
 	boolean Reset (void);
 	void EnableCommonInterrupts (void);
 	void EnableDeviceInterrupts (void);
diff --git a/include/circle/usb/gadget/dwusbgadgetendpoint.h b/include/circle/usb/gadget/dwusbgadgetendpoint.h
index 896b8c38..fd7a98b5 100644
--- a/include/circle/usb/gadget/dwusbgadgetendpoint.h
+++ b/include/circle/usb/gadget/dwusbgadgetendpoint.h
@@ -2,7 +2,7 @@
 // dwusbgadgetendpoint.h
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -51,6 +51,10 @@ public:
 	/// \note Override this to start first transfer.
 	virtual void OnActivate (void) = 0;
 
+	/// \brief Called to deactivate/stop EP processing.
+	/// \note Override this to stop first transfer.
+	virtual void OnDeactivate (void) = 0;
+
 	/// \brief Called, when the current transfer completes.
 	/// \param bIn Was it an IN transfer?
 	/// \param nLength Number of transferred bytes
@@ -61,6 +65,10 @@ public:
 	/// \note Override this to abort pending transfers.
 	virtual void OnSuspend (void) {}
 
+	/// \brief Set maximum packet size
+	/// \param nMaxPacketSize New maximum packet size
+	void SetMaxPacketSize (size_t nMaxPacketSize);
+
 protected:
 	/// \return Endpoint number (0-15)
 	unsigned GetEPNumber (void) const
@@ -111,6 +119,9 @@ protected:
 	/// \note The buffer must be declared as DMA_BUFFER
 	void BeginTransfer (TTransferMode Mode, void *pBuffer, size_t nLength);
 
+	/// \brief Cancel a began transfer
+	void CancelTransfer (void);
+
 	/// \brief Send STALL response
 	/// \param bIn STALL next IN request, or OUT otherwise?
 	void Stall (boolean bIn);
diff --git a/include/circle/usb/gadget/dwusbgadgetendpoint0.h b/include/circle/usb/gadget/dwusbgadgetendpoint0.h
index 51f8a6e2..a777355e 100644
--- a/include/circle/usb/gadget/dwusbgadgetendpoint0.h
+++ b/include/circle/usb/gadget/dwusbgadgetendpoint0.h
@@ -2,7 +2,7 @@
 // dwusbgadgetendpoint0.h
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -32,6 +32,7 @@ public:
 	~CDWUSBGadgetEndpoint0 (void);
 
 	void OnActivate (void) override;
+	void OnDeactivate (void) override;
 
 	void OnControlMessage (void) override;
 
diff --git a/include/circle/usb/gadget/usbcdcgadget.h b/include/circle/usb/gadget/usbcdcgadget.h
index db5bc736..9728158a 100644
--- a/include/circle/usb/gadget/usbcdcgadget.h
+++ b/include/circle/usb/gadget/usbcdcgadget.h
@@ -27,6 +27,7 @@
 #include <circle/usb/usbserial.h>
 #include <circle/usb/usb.h>
 #include <circle/interrupt.h>
+#include <circle/sysconfig.h>
 #include <circle/macros.h>
 #include <circle/types.h>
 
@@ -61,7 +62,11 @@ class CUSBCDCGadget : public CDWUSBGadget	/// USB serial CDC gadget
 {
 public:
 	/// \param pInterruptSystem Pointer to the interrupt system object
-	CUSBCDCGadget (CInterruptSystem *pInterruptSystem);
+	/// \param usVendorID USB vendor ID of the gadget
+	/// \param usProductID USB product ID of the gadget
+	CUSBCDCGadget (CInterruptSystem *pInterruptSystem,
+		       u16 usVendorID = USB_GADGET_VENDOR_ID,
+		       u16 usProductID = USB_GADGET_DEVICE_ID_SERIAL_CDC);
 
 	~CUSBCDCGadget (void);
 
@@ -103,7 +108,7 @@ private:
 	u8 m_StringDescriptorBuffer[80];
 
 private:
-	static const TUSBDeviceDescriptor s_DeviceDescriptor;
+	static TUSBDeviceDescriptor s_DeviceDescriptor;
 
 	struct TUSBCDCGadgetConfigurationDescriptor
 	{
diff --git a/include/circle/usb/gadget/usbcdcgadgetendpoint.h b/include/circle/usb/gadget/usbcdcgadgetendpoint.h
index 57dcb7d5..9f3f3805 100644
--- a/include/circle/usb/gadget/usbcdcgadgetendpoint.h
+++ b/include/circle/usb/gadget/usbcdcgadgetendpoint.h
@@ -4,7 +4,7 @@
 // This file by Sebastien Nicolas <seba1978@gmx.de>
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -41,6 +41,7 @@ public:
 	void AttachInterface (CUSBSerialDevice *pInterface);
 
 	void OnActivate (void) override;
+	void OnDeactivate (void) override;
 
 	void OnTransferComplete (boolean bIn, size_t nLength) override;
 
diff --git a/include/circle/usb/gadget/usbmidigadget.h b/include/circle/usb/gadget/usbmidigadget.h
index b563aa90..cce45b6f 100644
--- a/include/circle/usb/gadget/usbmidigadget.h
+++ b/include/circle/usb/gadget/usbmidigadget.h
@@ -26,6 +26,7 @@
 #include <circle/usb/usb.h>
 #include <circle/usb/usbaudio.h>
 #include <circle/interrupt.h>
+#include <circle/sysconfig.h>
 #include <circle/macros.h>
 #include <circle/types.h>
 
@@ -33,7 +34,11 @@ class CUSBMIDIGadget : public CDWUSBGadget	/// USB MIDI (v1.0) gadget
 {
 public:
 	/// \param pInterruptSystem Pointer to the interrupt system object
-	CUSBMIDIGadget (CInterruptSystem *pInterruptSystem);
+	/// \param usVendorID USB vendor ID of the gadget
+	/// \param usProductID USB product ID of the gadget
+	CUSBMIDIGadget (CInterruptSystem *pInterruptSystem,
+			u16 usVendorID = USB_GADGET_VENDOR_ID,
+			u16 usProductID = USB_GADGET_DEVICE_ID_MIDI);
 
 	~CUSBMIDIGadget (void);
 
@@ -74,7 +79,7 @@ private:
 	u8 m_StringDescriptorBuffer[80];
 
 private:
-	static const TUSBDeviceDescriptor s_DeviceDescriptor;
+	static TUSBDeviceDescriptor s_DeviceDescriptor;
 
 	struct TUSBMIDIGadgetConfigurationDescriptor
 	{
diff --git a/include/circle/usb/gadget/usbmidigadgetendpoint.h b/include/circle/usb/gadget/usbmidigadgetendpoint.h
index e7609f26..73c46749 100644
--- a/include/circle/usb/gadget/usbmidigadgetendpoint.h
+++ b/include/circle/usb/gadget/usbmidigadgetendpoint.h
@@ -2,7 +2,7 @@
 // usbmidigadgetendpoint.h
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -38,6 +38,7 @@ public:
 	void AttachInterface (CUSBMIDIDevice *pInterface);
 
 	void OnActivate (void) override;
+	void OnDeactivate (void) override;
 
 	void OnTransferComplete (boolean bIn, size_t nLength) override;
 
diff --git a/include/circle/usb/gadget/usbmsdgadget.h b/include/circle/usb/gadget/usbmsdgadget.h
index 1ad7f357..a83df9e0 100644
--- a/include/circle/usb/gadget/usbmsdgadget.h
+++ b/include/circle/usb/gadget/usbmsdgadget.h
@@ -4,7 +4,7 @@
 // USB Mass Storage Gadget by Mike Messinides
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -28,6 +28,7 @@
 #include <circle/interrupt.h>
 #include <circle/device.h>
 #include <circle/synchronize.h>
+#include <circle/sysconfig.h>
 #include <circle/macros.h>
 #include <circle/types.h>
 
@@ -141,9 +142,13 @@ class CUSBMSDGadget : public CDWUSBGadget	/// USB mass storage device gadget
 public:
 	/// \param pInterruptSystem Pointer to the interrupt system object
 	/// \param pDevice Pointer to the block device, to be controlled by this gadget
+	/// \param usVendorID USB vendor ID of the gadget
+	/// \param usProductID USB product ID of the gadget
 	/// \note pDevice must be initialized yet, when it is specified here.
 	/// \note SetDevice() has to be called later, when pDevice is not specified here.
-	CUSBMSDGadget (CInterruptSystem *pInterruptSystem, CDevice *pDevice = nullptr);
+	CUSBMSDGadget (CInterruptSystem *pInterruptSystem, CDevice *pDevice = nullptr,
+		       u16 usVendorID = USB_GADGET_VENDOR_ID,
+		       u16 usProductID = USB_GADGET_DEVICE_ID_MSD);
 
 	~CUSBMSDGadget (void);
 
@@ -184,12 +189,15 @@ private:
 
 	int OnClassOrVendorRequest (const TSetupData *pSetupData, u8 *pData) override;
 
+	void OnNegotiatedSpeed (TDeviceSpeed Speed) override;
+
 private:
 	friend class CUSBMSDGadgetEndpoint;
 
 	void OnTransferComplete (boolean bIn, size_t nLength);
 
 	void OnActivate(); //called from OUT ep
+	void OnDeactivate();
 
 private:
 	void HandleSCSICommand();
@@ -213,7 +221,7 @@ private:
 	u8 m_StringDescriptorBuffer[80];
 
 private:
-	static const TUSBDeviceDescriptor s_DeviceDescriptor;
+	static TUSBDeviceDescriptor s_DeviceDescriptor;
 
 	struct TUSBMSTGadgetConfigurationDescriptor
 	{
diff --git a/include/circle/usb/gadget/usbmsdgadgetendpoint.h b/include/circle/usb/gadget/usbmsdgadgetendpoint.h
index 0cc2bb9f..b13642e2 100644
--- a/include/circle/usb/gadget/usbmsdgadgetendpoint.h
+++ b/include/circle/usb/gadget/usbmsdgadgetendpoint.h
@@ -4,7 +4,7 @@
 // USB Mass Storage Gadget by Mike Messinides
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -36,6 +36,7 @@ public:
 	~CUSBMSDGadgetEndpoint (void);
 
 	void OnActivate (void) override;
+	void OnDeactivate (void) override;
 
 	void OnTransferComplete (boolean bIn, size_t nLength) override;
 
@@ -51,6 +52,7 @@ private:
 	};
 
 	void BeginTransfer (TMSDTransferMode Mode, void *pBuffer, size_t nLength);
+	void CancelTransfer (void);
 
 	void StallRequest(boolean bIn);
 
diff --git a/include/circle/usb/usbcdcethernet.h b/include/circle/usb/usbcdcethernet.h
index d91de161..00d10e2d 100644
--- a/include/circle/usb/usbcdcethernet.h
+++ b/include/circle/usb/usbcdcethernet.h
@@ -25,6 +25,7 @@
 #include <circle/usb/usbendpoint.h>
 #include <circle/usb/usbrequest.h>
 #include <circle/macaddress.h>
+#include <circle/synchronize.h>
 #include <circle/types.h>
 
 class CUSBCDCEthernetDevice : public CUSBFunction, CNetDevice
@@ -45,6 +46,8 @@ public:
 	boolean SetMulticastFilter (const u8 Groups[][MAC_ADDRESS_SIZE]);
 
 private:
+	static void CompletionRoutine (CUSBRequest *pURB, void *pParam, void *pContext);
+
 	u8 GetMACAddressStringIndex (void);	// returns 0 on error
 
 	boolean InitMACAddress (u8 iMACAddress);
@@ -58,6 +61,10 @@ private:
 	CUSBEndpoint *m_pEndpointBulkOut;
 
 	CMACAddress m_MACAddress;
+
+	CUSBRequest *volatile m_pURB;
+	DMA_BUFFER (u8, m_RxBuffer, FRAME_BUFFER_SIZE);
+	volatile unsigned m_nRxLength;
 };
 
 #endif
diff --git a/lib/usb/gadget/dwusbgadget.cpp b/lib/usb/gadget/dwusbgadget.cpp
index dc3f93cd..b5ea3872 100644
--- a/lib/usb/gadget/dwusbgadget.cpp
+++ b/lib/usb/gadget/dwusbgadget.cpp
@@ -120,6 +120,10 @@ boolean CDWUSBGadget::Initialize (boolean bScanDevices)
 
 	AddEndpoints ();
 
+	// *** CRITICAL: Initialize EP0 NOW, after EP is created but before interrupts enabled ***
+	// This matches Linux kernel pattern where EP0 setup happens in dwc2_hsotg_core_init_disconnected()
+	InitializeEP0 ();
+
 	m_State = StateSuspended;
 
 	// Enable all interrupts
@@ -132,6 +136,124 @@ boolean CDWUSBGadget::Initialize (boolean bScanDevices)
 	return TRUE;
 }
 
+void CDWUSBGadget::InitializeEP0 (void)
+{
+	// Guard: EP0 must exist before we can initialize it
+	if (!m_pEP[0])
+	{
+#ifdef USB_GADGET_DEBUG
+		LOGDBG ("InitializeEP0 called but EP0 doesn't exist yet - skipping");
+#endif
+		return;
+	}
+
+	// Enable common OUT EP interrupts (BCM2835 rejects SETUP_RCVD bit 15)
+	u32 nOutMaskValue = DWHCI_DEV_OUT_EP_INT_SETUP_DONE
+			  | DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE
+			  | DWHCI_DEV_OUT_EP_INT_AHB_ERROR
+			  | DWHCI_DEV_OUT_EP_INT_EP_DISABLED;
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Setting OUT EP common mask to 0x0000000F (SETUP_RCVD excluded per BCM2835 quirk)", nOutMaskValue);
+#endif
+	CDWHCIRegister OutEPCommonIntMask (DWHCI_DEV_OUT_EP_COMMON_INT_MASK, nOutMaskValue);
+	OutEPCommonIntMask.Write ();
+#ifdef USB_GADGET_DEBUG
+	u32 nReadBack = OutEPCommonIntMask.Read ();
+	LOGDBG ("OUT EP common mask readback: 0x%08X (expected 0x%08X)", nReadBack, nOutMaskValue);
+#endif
+
+	// Enable common IN EP interrupts
+	CDWHCIRegister InEPCommonIntMask (DWHCI_DEV_IN_EP_COMMON_INT_MASK,
+					    DWHCI_DEV_IN_EP_INT_XFER_COMPLETE
+					  | DWHCI_DEV_IN_EP_INT_TIMEOUT
+					  | DWHCI_DEV_IN_EP_INT_AHB_ERROR
+					  | DWHCI_DEV_IN_EP_INT_EP_DISABLED);
+	InEPCommonIntMask.Write ();
+
+	// Get EP0 max packet size
+	size_t nEP0MaxPacket = m_pEP[0]->m_nMaxPacketSize;
+	u32 nEP0MPS;
+	switch (nEP0MaxPacket)
+	{
+	case 64:	nEP0MPS = 0;	break;  // D0EPCTL_MPS_64 = 0
+	case 32:	nEP0MPS = 1;	break;  // D0EPCTL_MPS_32 = 1
+	case 16:	nEP0MPS = 2;	break;  // D0EPCTL_MPS_16 = 2
+	case 8:		nEP0MPS = 3;	break;  // D0EPCTL_MPS_8  = 3
+	default:
+		LOGERR ("Invalid EP0 max packet size: %u", nEP0MaxPacket);
+		nEP0MPS = 0;  // Default to 64
+		break;
+	}
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("EP0 direct initialization: MPS=%u (encoded value 0x%X)", nEP0MaxPacket, nEP0MPS);
+#endif
+
+	// Set up EP0 OUT transfer size for 1 SETUP packet of 8 bytes
+	CDWHCIRegister OutEP0XferSize (DWHCI_DEV_OUT_EP_XFER_SIZ (0), 0);
+	OutEP0XferSize.Or (1 << DWHCI_DEV_EP_XFER_SIZ_PKT_CNT__SHIFT);
+	OutEP0XferSize.Or (8 << DWHCI_DEV_EP_XFER_SIZ_XFER_SIZ__SHIFT);
+	OutEP0XferSize.Write ();
+
+	// Direct write to DOEPCTL0 (not read-modify-write!)
+	// EP0 registers were just cleared in InitCoreDevice(), so we can write directly
+	u32 nOutEP0Ctrl = nEP0MPS  // MPS in bits [1:0]
+			| DWHCI_DEV_EP_CTRL_ACTIVE_EP
+			| DWHCI_DEV_EP_CTRL_EP_ENABLE;
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Writing DOEPCTL0 = 0x%08X (MPS=%u | ACTIVE | EPENA)", nOutEP0Ctrl, nEP0MPS);
+#endif
+
+	CDWHCIRegister OutEP0Ctrl (DWHCI_DEV_OUT_EP_CTRL (0), nOutEP0Ctrl);
+	OutEP0Ctrl.Write ();
+	DataMemBarrier ();
+
+#ifdef USB_GADGET_DEBUG
+	u32 nOutEP0CtrlReadback = OutEP0Ctrl.Read ();
+	LOGDBG ("DOEPCTL0 readback = 0x%08X", nOutEP0CtrlReadback);
+#endif
+
+	// Set up EP0 IN - just set MPS and ACTIVE (no EPENA yet)
+	u32 nInEP0Ctrl = nEP0MPS  // MPS in bits [1:0]
+		       | DWHCI_DEV_EP_CTRL_ACTIVE_EP;
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Writing DIEPCTL0 = 0x%08X (MPS=%u | ACTIVE)", nInEP0Ctrl, nEP0MPS);
+#endif
+
+	CDWHCIRegister InEP0CtrlWrite (DWHCI_DEV_IN_EP_CTRL (0), nInEP0Ctrl);
+	InEP0CtrlWrite.Write ();
+
+	// Enable EP0 in DAINT mask
+	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
+	AllEPsIntMask.Read ();
+	AllEPsIntMask.Or (DWHCI_DEV_ALL_EPS_INT_MASK_IN_EP (0));
+	AllEPsIntMask.Or (DWHCI_DEV_ALL_EPS_INT_MASK_OUT_EP (0));
+	AllEPsIntMask.Write ();
+
+	// Clear global NAKs
+	CDWHCIRegister DeviceControl (DWHCI_DEV_CTRL);
+	DeviceControl.Read ();
+	DeviceControl.Set (DWHCI_DEV_CTRL_CLEAR_GLOBAL_OUT_NAK);
+	DeviceControl.Set (DWHCI_DEV_CTRL_CLEAR_GLOBAL_NON_PER_IN_NAK);
+	DeviceControl.Write ();
+	DataMemBarrier ();
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Global NAKs cleared, EP0 ready for SETUP packets");
+	
+	// Dump critical register states
+	CDWHCIRegister DumpDOEPCTL0 (DWHCI_DEV_OUT_EP_CTRL (0));
+	CDWHCIRegister DumpDIEPCTL0 (DWHCI_DEV_IN_EP_CTRL (0));
+	CDWHCIRegister DumpDAINTMSK (DWHCI_DEV_ALL_EPS_INT_MASK);
+	CDWHCIRegister DumpDOEPMSK (DWHCI_DEV_OUT_EP_COMMON_INT_MASK);
+	
+	LOGDBG ("InitializeEP0 exit: DOEPCTL0=0x%08X DIEPCTL0=0x%08X DAINTMSK=0x%08X DOEPMSK=0x%08X",
+		DumpDOEPCTL0.Read(), DumpDIEPCTL0.Read(), DumpDAINTMSK.Read(), DumpDOEPMSK.Read());
+#endif
+}
+
 boolean CDWUSBGadget::UpdatePlugAndPlay (void)
 {
 	boolean bResult = FALSE;
@@ -167,6 +289,9 @@ boolean CDWUSBGadget::UpdatePlugAndPlay (void)
 
 		AddEndpoints ();
 
+		// *** ADD THIS: Initialize EP0 after recreating it ***
+		InitializeEP0 ();
+
 		m_State = StateSuspended;
 
 		// Enable all interrupts
@@ -394,6 +519,117 @@ void CDWUSBGadget::InitCoreDevice (void)
 	InEPCommonIntMask.Read ();
 	InEPCommonIntMask.Or (DWHCI_DEV_IN_EP_COMMON_INT_MASK_FIFO_UNDERRUN);
 	InEPCommonIntMask.Write ();
+
+	// *** CRITICAL: Initialize EP0 immediately after core/EP setup ***
+	// EP0 must be configured NOW, after registers are cleared but before any USB activity
+	// This matches Linux kernel pattern where EP0 is set up during dwc2_hsotg_core_init_disconnected()
+	
+	// Enable common OUT EP interrupts (BCM2835 rejects SETUP_RCVD bit 15)
+	u32 nOutMaskValue = DWHCI_DEV_OUT_EP_INT_SETUP_DONE
+			  | DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE
+			  | DWHCI_DEV_OUT_EP_INT_AHB_ERROR
+			  | DWHCI_DEV_OUT_EP_INT_EP_DISABLED;
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Setting OUT EP common mask to 0x%08X (SETUP_RCVD excluded per BCM2835 quirk)", nOutMaskValue);
+#endif
+	CDWHCIRegister OutEPCommonIntMask (DWHCI_DEV_OUT_EP_COMMON_INT_MASK, nOutMaskValue);
+	OutEPCommonIntMask.Write ();
+#ifdef USB_GADGET_DEBUG
+	u32 nReadBack = OutEPCommonIntMask.Read ();
+	LOGDBG ("OUT EP common mask readback: 0x%08X (expected 0x%08X)", nReadBack, nOutMaskValue);
+#endif
+
+	// Enable common IN EP interrupts
+	CDWHCIRegister InEPCommonIntMaskEP0 (DWHCI_DEV_IN_EP_COMMON_INT_MASK,
+					    DWHCI_DEV_IN_EP_INT_XFER_COMPLETE
+					  | DWHCI_DEV_IN_EP_INT_TIMEOUT
+					  | DWHCI_DEV_IN_EP_INT_AHB_ERROR
+					  | DWHCI_DEV_IN_EP_INT_EP_DISABLED);
+	InEPCommonIntMaskEP0.Write ();
+
+	// Get EP0 max packet size - EP0 must already be created at this point
+	assert (m_pEP[0]);
+	size_t nEP0MaxPacket = m_pEP[0]->m_nMaxPacketSize;
+	u32 nEP0MPS;
+	switch (nEP0MaxPacket)
+	{
+	case 64:	nEP0MPS = 0;	break;  // D0EPCTL_MPS_64 = 0
+	case 32:	nEP0MPS = 1;	break;  // D0EPCTL_MPS_32 = 1
+	case 16:	nEP0MPS = 2;	break;  // D0EPCTL_MPS_16 = 2
+	case 8:		nEP0MPS = 3;	break;  // D0EPCTL_MPS_8  = 3
+	default:
+		LOGERR ("Invalid EP0 max packet size: %u", nEP0MaxPacket);
+		nEP0MPS = 0;  // Default to 64
+		break;
+	}
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("EP0 direct initialization: MPS=%u (encoded value 0x%X)", nEP0MaxPacket, nEP0MPS);
+#endif
+
+	// Set up EP0 OUT transfer size for 1 SETUP packet of 8 bytes
+	CDWHCIRegister OutEP0XferSize (DWHCI_DEV_OUT_EP_XFER_SIZ (0), 0);
+	OutEP0XferSize.Or (1 << DWHCI_DEV_EP_XFER_SIZ_PKT_CNT__SHIFT);
+	OutEP0XferSize.Or (8 << DWHCI_DEV_EP_XFER_SIZ_XFER_SIZ__SHIFT);
+	OutEP0XferSize.Write ();
+
+	// Direct write to DOEPCTL0 (not read-modify-write!)
+	// EP0 is freshly cleared from loop above, so we can write directly
+	u32 nOutEP0Ctrl = nEP0MPS  // MPS in bits [1:0]
+			| DWHCI_DEV_EP_CTRL_ACTIVE_EP
+			| DWHCI_DEV_EP_CTRL_EP_ENABLE;
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Writing DOEPCTL0 = 0x%08X (MPS=%u | ACTIVE | EPENA)", nOutEP0Ctrl, nEP0MPS);
+#endif
+
+	CDWHCIRegister OutEP0Ctrl (DWHCI_DEV_OUT_EP_CTRL (0), nOutEP0Ctrl);
+	OutEP0Ctrl.Write ();
+	DataMemBarrier ();
+
+#ifdef USB_GADGET_DEBUG
+	u32 nOutEP0CtrlReadback = OutEP0Ctrl.Read ();
+	LOGDBG ("DOEPCTL0 readback = 0x%08X", nOutEP0CtrlReadback);
+#endif
+
+	// Set up EP0 IN - just set MPS and ACTIVE (no EPENA yet)
+	u32 nInEP0Ctrl = nEP0MPS  // MPS in bits [1:0]
+		       | DWHCI_DEV_EP_CTRL_ACTIVE_EP;
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Writing DIEPCTL0 = 0x%08X (MPS=%u | ACTIVE)", nInEP0Ctrl, nEP0MPS);
+#endif
+
+	CDWHCIRegister InEP0CtrlWrite (DWHCI_DEV_IN_EP_CTRL (0), nInEP0Ctrl);
+	InEP0CtrlWrite.Write ();
+
+	// Enable EP0 in DAINT mask
+	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
+	AllEPsIntMask.Read ();
+	AllEPsIntMask.Or (DWHCI_DEV_ALL_EPS_INT_MASK_IN_EP (0));
+	AllEPsIntMask.Or (DWHCI_DEV_ALL_EPS_INT_MASK_OUT_EP (0));
+	AllEPsIntMask.Write ();
+
+	// Clear global NAKs
+	CDWHCIRegister DeviceControl (DWHCI_DEV_CTRL);
+	DeviceControl.Read ();
+	DeviceControl.Set (DWHCI_DEV_CTRL_CLEAR_GLOBAL_OUT_NAK);
+	DeviceControl.Set (DWHCI_DEV_CTRL_CLEAR_GLOBAL_NON_PER_IN_NAK);
+	DeviceControl.Write ();
+	DataMemBarrier ();
+
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("Global NAKs cleared, EP0 ready for SETUP packets");
+	
+	// Dump critical register states
+	CDWHCIRegister DumpDOEPCTL0 (DWHCI_DEV_OUT_EP_CTRL (0));
+	CDWHCIRegister DumpDIEPCTL0 (DWHCI_DEV_IN_EP_CTRL (0));
+	CDWHCIRegister DumpDAINTMSK (DWHCI_DEV_ALL_EPS_INT_MASK);
+	CDWHCIRegister DumpDOEPMSK (DWHCI_DEV_OUT_EP_COMMON_INT_MASK);
+	
+	LOGDBG ("InitCoreDevice exit: DOEPCTL0=0x%08X DIEPCTL0=0x%08X DAINTMSK=0x%08X DOEPMSK=0x%08X",
+		DumpDOEPCTL0.Read(), DumpDIEPCTL0.Read(), DumpDAINTMSK.Read(), DumpDOEPMSK.Read());
+#endif
 }
 
 boolean CDWUSBGadget::Reset (void)
@@ -435,6 +671,7 @@ void CDWUSBGadget::EnableDeviceInterrupts (void)
 	IntStatus.Write ();
 
 	// Enable interrupts
+	IntMask.Or (DWHCI_CORE_INT_MASK_RX_STS_Q_LVL);	// Required for SETUP packets in slave mode
 	IntMask.Or (DWHCI_CORE_INT_MASK_USB_SUSPEND);
 	IntMask.Or (DWHCI_CORE_INT_MASK_USB_RESET_INTR);
 	IntMask.Or (DWHCI_CORE_INT_MASK_ENUM_DONE);
@@ -506,14 +743,24 @@ void CDWUSBGadget::HandleUSBSuspend (void)
 	LOGDBG ("USB suspend");
 #endif
 
-	m_bPnPEvent[PnPEventSuspend] = TRUE;
-
-	for (unsigned i = 0; i <= NumberOfEPs; i++)
+	if (   m_State != StatePowered
+	    && m_State != StateSuspended)
 	{
-		if (m_pEP[i])
+		m_bPnPEvent[PnPEventSuspend] = TRUE;
+
+		for (unsigned i = 0; i <= NumberOfEPs; i++)
 		{
-			m_pEP[i]->OnSuspend ();
+			if (m_pEP[i])
+			{
+				m_pEP[i]->OnSuspend ();
+			}
 		}
+
+		// Disable all interrupts
+		CDWHCIRegister AHBConfig (DWHCI_CORE_AHB_CFG);
+		AHBConfig.Read ();
+		AHBConfig.And (~DWHCI_CORE_AHB_CFG_GLOBALINT_MASK);
+		AHBConfig.Write ();
 	}
 
 	CDWHCIRegister IntStatus (DWHCI_CORE_INT_STAT, DWHCI_CORE_INT_MASK_USB_SUSPEND);
@@ -526,6 +773,24 @@ void CDWUSBGadget::HandleUSBReset (void)
 	LOGDBG ("USB reset");
 #endif
 
+	// Reset device address to 0 FIRST (Linux kernel pattern)
+	SetDeviceAddress (0);
+
+	switch (m_State)
+	{
+	case StateConfigured:
+		SetConfiguration (0);
+		// fall through
+
+	case StateEnumDone:
+		assert (m_pEP[0]);
+		m_pEP[0]->OnDeactivate ();
+		break;
+
+	default:
+		break;
+	}
+
 	// Set NAK for all OUT EPs
 	for (unsigned i = 0; i <= NumberOfOutEPs; i++)
 	{
@@ -534,7 +799,31 @@ void CDWUSBGadget::HandleUSBReset (void)
 		OutEPCtrl.Write ();
 	}
 
+	// Clear STALL on all non-EP0 endpoints (Linux kernel pattern)
+	for (unsigned i = 1; i <= NumberOfEPs; i++)
+	{
+		CDWHCIRegister InEPCtrl (DWHCI_DEV_IN_EP_CTRL (i));
+		InEPCtrl.Read ();
+		if (InEPCtrl.Get () & DWHCI_DEV_EP_CTRL_STALL)
+		{
+			InEPCtrl.And (~DWHCI_DEV_EP_CTRL_STALL);
+			InEPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D0);  // Reset to DATA0
+			InEPCtrl.Write ();
+		}
+
+		CDWHCIRegister OutEPCtrl (DWHCI_DEV_OUT_EP_CTRL (i));
+		OutEPCtrl.Read ();
+		if (OutEPCtrl.Get () & DWHCI_DEV_EP_CTRL_STALL)
+		{
+			OutEPCtrl.And (~DWHCI_DEV_EP_CTRL_STALL);
+			OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D0);
+			OutEPCtrl.Write ();
+		}
+	}
+
+	// Flush all FIFOs (Linux kernel pattern)
 	FlushTxFIFO (0x10);
+	FlushRxFIFO ();
 
 	// Flush learning queue
 	CDWHCIRegister Reset (DWHCI_CORE_RESET, DWHCI_CORE_RESET_IN_TOKEN_QUEUE_FLUSH);
@@ -555,24 +844,6 @@ void CDWUSBGadget::HandleUSBReset (void)
 	DeviceConfig.Or (2 << DWHCI_DEV_CFG_EP_MISMATCH_COUNT__SHIFT);
 	DeviceConfig.Write ();
 
-	// Enable common OUT EP interrupts
-	CDWHCIRegister OutEPCommonIntMask (DWHCI_DEV_OUT_EP_COMMON_INT_MASK,
-					     DWHCI_DEV_OUT_EP_INT_SETUP_DONE
-					   | DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE
-					   | DWHCI_DEV_OUT_EP_INT_AHB_ERROR
-					   | DWHCI_DEV_OUT_EP_INT_EP_DISABLED);
-	OutEPCommonIntMask.Write ();
-
-	// Enable common IN EP interrupts
-	CDWHCIRegister InEPCommonIntMask (DWHCI_DEV_IN_EP_COMMON_INT_MASK,
-					    DWHCI_DEV_IN_EP_INT_XFER_COMPLETE
-					  | DWHCI_DEV_IN_EP_INT_TIMEOUT
-					  | DWHCI_DEV_IN_EP_INT_AHB_ERROR
-					  | DWHCI_DEV_IN_EP_INT_EP_DISABLED);
-	InEPCommonIntMask.Write ();
-
-	SetDeviceAddress (0);
-
 	// Notify all EPs about USB reset
 	for (unsigned i = 0; i <= NumberOfEPs; i++)
 	{
@@ -582,6 +853,18 @@ void CDWUSBGadget::HandleUSBReset (void)
 		}
 	}
 
+	// Re-arm EP0 OUT for SETUP reception after USB reset
+	// EP0 is already configured from InitCoreDevice(), we just need to reset the transfer size
+	CDWHCIRegister OutEP0XferSize (DWHCI_DEV_OUT_EP_XFER_SIZ (0), 0);
+	OutEP0XferSize.Or (1 << DWHCI_DEV_EP_XFER_SIZ_PKT_CNT__SHIFT);
+	OutEP0XferSize.Or (8 << DWHCI_DEV_EP_XFER_SIZ_XFER_SIZ__SHIFT);
+	OutEP0XferSize.Write ();
+
+#ifdef USB_GADGET_DEBUG
+	CDWHCIRegister DumpDOEPCTL0 (DWHCI_DEV_OUT_EP_CTRL (0));
+	LOGDBG ("USB reset complete: DOEPCTL0=0x%08X (should still be enabled)", DumpDOEPCTL0.Read());
+#endif
+
 	m_State = StateResetDone;
 
 	CDWHCIRegister IntStatus (DWHCI_CORE_INT_STAT, DWHCI_CORE_INT_MASK_USB_RESET_INTR);
@@ -607,12 +890,17 @@ void CDWUSBGadget::HandleEnumerationDone (void)
 		USBConfig.Or (9 << DWHCI_CORE_USB_CFG_TURNAROUND_TIME__SHIFT);
 		USBConfig.Write ();
 
-		assert (m_pEP[0]);
-		m_pEP[0]->OnActivate ();
+		TDeviceSpeed Speed = GetNegotiatedUSBSpeed ();
+		OnNegotiatedSpeed (Speed);
 
 		m_State = StateEnumDone;
 	}
 
+	// Always re-arm EP0 after enumeration done, even if already in StateEnumDone
+	// (handles cases where host resets during enumeration)
+	assert (m_pEP[0]);
+	m_pEP[0]->OnActivate ();
+
 	assert (m_State == StateEnumDone);
 
 	CDWHCIRegister IntStatus (DWHCI_CORE_INT_STAT, DWHCI_CORE_INT_MASK_ENUM_DONE);
@@ -621,17 +909,18 @@ void CDWUSBGadget::HandleEnumerationDone (void)
 
 void CDWUSBGadget::HandleInEPInterrupt (void)
 {
+	CDWHCIRegister AllEPsIntStat (DWHCI_DEV_ALL_EPS_INT_STAT);
+	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
+	u32 nInEPStat = (AllEPsIntStat.Read () & AllEPsIntMask.Read ()) & 0xFFFF;
+
 #ifdef USB_GADGET_DEBUG
-	LOGDBG ("In EP interrupt");
+	LOGDBG ("In EP interrupt: stat=0x%08X mask=0x%08X filtered=0x%04X",
+		AllEPsIntStat.Read(), AllEPsIntMask.Read(), nInEPStat);
 #endif
 
 	assert (   m_State == StateEnumDone
 		|| m_State == StateConfigured);
 
-	CDWHCIRegister AllEPsIntStat (DWHCI_DEV_ALL_EPS_INT_STAT);
-	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
-	u32 nInEPStat = (AllEPsIntStat.Read () & AllEPsIntMask.Read ()) & 0xFFFF;
-
 	for (unsigned nEP = 0; nInEPStat; nInEPStat >>= 1, nEP++)
 	{
 		if (nInEPStat & 1)
@@ -645,24 +934,36 @@ void CDWUSBGadget::HandleInEPInterrupt (void)
 
 void CDWUSBGadget::HandleOutEPInterrupt (void)
 {
+	CDWHCIRegister AllEPsIntStat (DWHCI_DEV_ALL_EPS_INT_STAT);
+	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
+	u32 nOutEPStat = (AllEPsIntStat.Read () & AllEPsIntMask.Read ()) >> 16;
+
 #ifdef USB_GADGET_DEBUG
-	LOGDBG ("Out EP interrupt");
+	LOGDBG ("Out EP interrupt: stat=0x%08X mask=0x%08X filtered=0x%04X", 
+		AllEPsIntStat.Read(), AllEPsIntMask.Read(), nOutEPStat);
 #endif
 
-	assert (   m_State == StateEnumDone
+	assert (   m_State == StateSuspended
+		|| m_State == StateEnumDone
 		|| m_State == StateConfigured);
 
-	CDWHCIRegister AllEPsIntStat (DWHCI_DEV_ALL_EPS_INT_STAT);
-	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
-	u32 nOutEPStat = (AllEPsIntStat.Read () & AllEPsIntMask.Read ()) >> 16;
-
 	for (unsigned nEP = 0; nOutEPStat; nOutEPStat >>= 1, nEP++)
 	{
 		if (nOutEPStat & 1)
 		{
-			assert (nEP <= NumberOfEPs);
-			assert (m_pEP[nEP]);
-			m_pEP[nEP]->HandleOutInterrupt ();
+			if (m_State != StateSuspended)
+			{
+				assert (nEP <= NumberOfEPs);
+				assert (m_pEP[nEP]);
+				m_pEP[nEP]->HandleOutInterrupt ();
+			}
+			else
+			{
+				CDWHCIRegister OutEPIntAck (DWHCI_DEV_OUT_EP_INT (nEP));
+				OutEPIntAck.Set (  DWHCI_DEV_OUT_EP_INT_SETUP_DONE
+						 | DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE);
+				OutEPIntAck.Write ();
+			}
 		}
 	}
 }
@@ -676,12 +977,51 @@ void CDWUSBGadget::InterruptHandler (void)
 	u32 nIntStatus = IntStatus.Read () & IntMask.Read ();
 
 #ifdef USB_GADGET_DEBUG
-	LOGDBG ("IRQ (status 0x%08X)", nIntStatus);
+	// Debug: Check all relevant registers when any interrupt fires
+	if (nIntStatus)
+	{
+		CDWHCIRegister EP0OutInt (DWHCI_DEV_OUT_EP_INT (0));
+		u32 nEP0OutInt = EP0OutInt.Read ();
+		CDWHCIRegister AllEPsIntStat (DWHCI_DEV_ALL_EPS_INT_STAT);
+		u32 nAllEPs = AllEPsIntStat.Read ();
+		CDWHCIRegister OutEPMask (DWHCI_DEV_OUT_EP_COMMON_INT_MASK);
+		u32 nOutEPMask = OutEPMask.Read ();
+		
+		LOGDBG ("IRQ: core=0x%08X allEPs=0x%08X ep0Out=0x%08X outMask=0x%08X state=%u",
+			nIntStatus, nAllEPs, nEP0OutInt, nOutEPMask, (unsigned) m_State);
+	}
 #endif
 
+	if (nIntStatus & DWHCI_CORE_INT_MASK_RX_STS_Q_LVL)
+	{
+#ifdef USB_GADGET_DEBUG
+		CDWHCIRegister RxStatus (DWHCI_CORE_RX_STAT_RD);
+		u32 nRxStat = RxStatus.Read ();
+		u32 nEPNum = nRxStat & DWHCI_CORE_RX_STAT_CHAN_NUMBER__MASK;
+		u32 nByteCount = (nRxStat & DWHCI_CORE_RX_STAT_BYTE_COUNT__MASK) >> DWHCI_CORE_RX_STAT_BYTE_COUNT__SHIFT;
+		u32 nPktStat = (nRxStat & DWHCI_CORE_RX_STAT_PACKET_STATUS__MASK) >> DWHCI_CORE_RX_STAT_PACKET_STATUS__SHIFT;
+		
+		LOGDBG ("  RX FIFO: ep=%u bytes=%u pktstat=%u (0x%08X)", nEPNum, nByteCount, nPktStat, nRxStat);
+		
+		// Log specific packet status types
+		if (nPktStat == 6) {
+			LOGDBG ("    -> SETUP packet received on EP%u", nEPNum);
+		} else if (nPktStat == 2) {
+			LOGDBG ("    -> OUT data packet received on EP%u", nEPNum);
+		} else if (nPktStat == 3) {
+			LOGDBG ("    -> OUT transfer complete on EP%u", nEPNum);
+		} else if (nPktStat == 4) {
+			LOGDBG ("    -> SETUP transaction complete on EP%u", nEPNum);
+		}
+#endif
+		// TODO: Implement RX FIFO handling if needed for slave mode
+	}
+
 	if (nIntStatus & DWHCI_CORE_INT_MASK_USB_SUSPEND)
 	{
 		HandleUSBSuspend ();
+
+		nIntStatus = 0;
 	}
 
 	if (nIntStatus & DWHCI_CORE_INT_MASK_USB_RESET_INTR)
@@ -748,10 +1088,35 @@ void CDWUSBGadget::SetDeviceAddress (u8 uchAddress)
 	DeviceConfig.And (~DWHCI_DEV_CFG_DEV_ADDR__MASK);
 	DeviceConfig.Or (uchAddress << DWHCI_DEV_CFG_DEV_ADDR__SHIFT);
 	DeviceConfig.Write ();
+
+	// Ensure hardware has processed the address change before returning
+	// (Linux kernel pattern - prevents host from timing out on next request)
+	DeviceConfig.Read ();  // Read back to ensure write completed
+	DataSyncBarrier ();     // Memory barrier to ensure ordering
 }
 
 boolean CDWUSBGadget::SetConfiguration (u8 uchConfiguration)
 {
+	if (uchConfiguration == 0)
+	{
+		if (m_State == StateEnumDone)
+		{
+			return TRUE;
+		}
+
+		m_State = StateEnumDone;
+
+		for (unsigned i = 1; i <= NumberOfEPs; i++)
+		{
+			if (m_pEP[i])
+			{
+				m_pEP[i]->OnDeactivate ();
+			}
+		}
+
+		return TRUE;
+	}
+
 	if (uchConfiguration != 1)
 	{
 		return FALSE;
@@ -782,3 +1147,22 @@ boolean CDWUSBGadget::SetConfiguration (u8 uchConfiguration)
 
 	return TRUE;
 }
+
+CDWUSBGadget::TDeviceSpeed CDWUSBGadget::GetNegotiatedUSBSpeed (void) const
+{
+	CDWHCIRegister DeviceStatus (DWHCI_DEV_STS);
+	u32 nEnumSpeed = (DeviceStatus.Read () & DWHCI_DEV_STS_ENUM_SPEED__MASK) >> DWHCI_DEV_STS_ENUM_SPEED__SHIFT;
+
+	switch (nEnumSpeed)
+	{
+	case DWHCI_DEV_STS_ENUM_SPEED_HS_30_60:
+		return HighSpeed;
+
+	case DWHCI_DEV_STS_ENUM_SPEED_FS_30_60:
+	case DWHCI_DEV_STS_ENUM_SPEED_FS_48:
+		return FullSpeed;
+
+	default:
+		return DeviceSpeedUnknown;
+	}
+}
\ No newline at end of file
diff --git a/lib/usb/gadget/dwusbgadgetendpoint.cpp b/lib/usb/gadget/dwusbgadgetendpoint.cpp
index d71abd08..f2f15fd5 100644
--- a/lib/usb/gadget/dwusbgadgetendpoint.cpp
+++ b/lib/usb/gadget/dwusbgadgetendpoint.cpp
@@ -2,7 +2,7 @@
 // dwusbgadgetendpoint.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -65,101 +65,117 @@ CDWUSBGadgetEndpoint::~CDWUSBGadgetEndpoint (void)
 	m_pGadget->RemoveEndpoint (m_nEP);
 }
 
+void CDWUSBGadgetEndpoint::SetMaxPacketSize (size_t nMaxPacketSize)
+{
+	m_nMaxPacketSize = nMaxPacketSize;
+
+	if (m_nEP != 0)
+	{
+		CDWHCIRegister EPCtrl (  m_Direction == DirectionIn
+				       ? DWHCI_DEV_IN_EP_CTRL (m_nEP)
+				       : DWHCI_DEV_OUT_EP_CTRL (m_nEP));
+		EPCtrl.Read ();
+		EPCtrl.And (~DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__MASK);
+		EPCtrl.Or (m_nMaxPacketSize << DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__SHIFT);
+		EPCtrl.Write ();
+	}
+}
+
 void CDWUSBGadgetEndpoint::OnUSBReset (void)
 {
 	InitTransfer ();
 
 	if (!m_nEP)
 	{
-		u32 nValue = 0;
-		switch (m_nMaxPacketSize)
-		{
-		case 8:		nValue = DWHCI_DEV_EP0_CTRL_MAX_PACKET_SIZ_8;	break;
-		case 16:	nValue = DWHCI_DEV_EP0_CTRL_MAX_PACKET_SIZ_16;	break;
-		case 32:	nValue = DWHCI_DEV_EP0_CTRL_MAX_PACKET_SIZ_32;	break;
-		case 64:	nValue = DWHCI_DEV_EP0_CTRL_MAX_PACKET_SIZ_64;	break;
-
-		default:
-			assert (0);
-			break;
-		}
-
-		CDWHCIRegister InEP0Ctrl (DWHCI_DEV_IN_EP_CTRL (0));
-		InEP0Ctrl.Read ();
-		InEP0Ctrl.And (~DWHCI_DEV_EP0_CTRL_MAX_PACKET_SIZ__MASK);
-		InEP0Ctrl.Or (nValue << DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__SHIFT);
-		InEP0Ctrl.Write ();
-
-		CDWHCIRegister OutEP0Ctrl (DWHCI_DEV_OUT_EP_CTRL (0));
-		OutEP0Ctrl.Read ();
-		OutEP0Ctrl.And (~DWHCI_DEV_EP0_CTRL_MAX_PACKET_SIZ__MASK);
-		OutEP0Ctrl.Or (nValue << DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__SHIFT);
-		OutEP0Ctrl.Write ();
+		// EP0: Max packet size is set during direct initialization in HandleUSBReset()
+		// We don't touch DOEPCTL0/DIEPCTL0 here to avoid interfering with the
+		// critical direct write that was done in CDWUSBGadget::HandleUSBReset()
+#ifdef USB_GADGET_DEBUG
+		LOGDBG ("EP0 OnUSBReset: Skipping control register writes (already initialized)");
+#endif
 	}
 	else
 	{
-		// dwc_otg_ep_activate()
+		// For non-EP0 endpoints, only reset data toggle to DATA0 on USB reset.
+		// Full activation (ACTIVE_EP) happens later during SET_CONFIGURATION.
+		// This follows the Linux kernel pattern where bulk endpoints are not
+		// activated until ep_enable() is called after configuration.
 		CDWHCIRegister EPCtrl (m_Direction == DirectionIn ? DWHCI_DEV_IN_EP_CTRL (m_nEP)
-								  : DWHCI_DEV_OUT_EP_CTRL (m_nEP));
+							  : DWHCI_DEV_OUT_EP_CTRL (m_nEP));
 		EPCtrl.Read ();
 
-		assert (!(EPCtrl.Get () & DWHCI_DEV_EP_CTRL_ACTIVE_EP));
-
-		EPCtrl.And (~DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__MASK);
-		EPCtrl.Or (m_nMaxPacketSize << DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__SHIFT);
-
-		assert (m_Type == TypeBulk);	// TODO: Bulk only
-		EPCtrl.And (~DWHCI_DEV_EP_CTRL_EP_TYPE__MASK);
-		EPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_TYPE_BULK << DWHCI_DEV_EP_CTRL_EP_TYPE__SHIFT);
-		EPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D0);
+		// If endpoint is already active, reconfigure it fully
+		if (EPCtrl.Get () & DWHCI_DEV_EP_CTRL_ACTIVE_EP)
+		{
+			EPCtrl.And (~DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__MASK);
+			EPCtrl.Or (m_nMaxPacketSize << DWHCI_DEV_EP_CTRL_MAX_PACKET_SIZ__SHIFT);
 
-		EPCtrl.Or (DWHCI_DEV_EP_CTRL_ACTIVE_EP);
+			assert (m_Type == TypeBulk);	// TODO: Bulk only
+			EPCtrl.And (~DWHCI_DEV_EP_CTRL_EP_TYPE__MASK);
+			EPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_TYPE_BULK << DWHCI_DEV_EP_CTRL_EP_TYPE__SHIFT);
+			EPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D0);
 
-		if (m_Direction == DirectionIn)
-		{
-			// Assign dedicated TX FIFO to EP
-			EPCtrl.And (~DWHCI_DEV_IN_EP_CTRL_TX_FIFO_NUM__MASK);
-			EPCtrl.Or (m_nEP << DWHCI_DEV_IN_EP_CTRL_TX_FIFO_NUM__SHIFT);
+			EPCtrl.Or (DWHCI_DEV_EP_CTRL_ACTIVE_EP);
 
-			// Update s_NextEPSeq[]
-			unsigned i;
-			for (i = 0; i <= CDWUSBGadget::NumberOfInEPs; i++)
+			if (m_Direction == DirectionIn)
 			{
-				if (s_NextEPSeq[i] == s_uchFirstInNextEPSeq)
+				// Assign dedicated TX FIFO to EP
+				EPCtrl.And (~DWHCI_DEV_IN_EP_CTRL_TX_FIFO_NUM__MASK);
+				EPCtrl.Or (m_nEP << DWHCI_DEV_IN_EP_CTRL_TX_FIFO_NUM__SHIFT);
+
+				// Update s_NextEPSeq[]
+				unsigned i;
+				for (i = 0; i <= CDWUSBGadget::NumberOfInEPs; i++)
 				{
-					break;
+					if (s_NextEPSeq[i] == s_uchFirstInNextEPSeq)
+					{
+						break;
+					}
 				}
-			}
 
-			assert (i <= CDWUSBGadget::NumberOfInEPs);
-			s_NextEPSeq[i] = m_nEP;
-			s_NextEPSeq[m_nEP] = s_uchFirstInNextEPSeq;
+				assert (i <= CDWUSBGadget::NumberOfInEPs);
+				s_NextEPSeq[i] = m_nEP;
+				s_NextEPSeq[m_nEP] = s_uchFirstInNextEPSeq;
 
-			EPCtrl.And (~DWHCI_DEV_IN_EP_CTRL_NEXT_EP__MASK);
-			EPCtrl.Or (s_NextEPSeq[m_nEP] << DWHCI_DEV_IN_EP_CTRL_NEXT_EP__SHIFT);
+				EPCtrl.And (~DWHCI_DEV_IN_EP_CTRL_NEXT_EP__MASK);
+				EPCtrl.Or (s_NextEPSeq[m_nEP] << DWHCI_DEV_IN_EP_CTRL_NEXT_EP__SHIFT);
 
 #ifdef USB_GADGET_DEBUG
-			LOGDBG ("First in next EP sequence is %u", s_uchFirstInNextEPSeq);
-			debug_hexdump (s_NextEPSeq, sizeof s_NextEPSeq, From);
+				LOGDBG ("First in next EP sequence is %u", s_uchFirstInNextEPSeq);
+				debug_hexdump (s_NextEPSeq, sizeof s_NextEPSeq, From);
 #endif
 
-			// Update EP mismatch count
-			CDWHCIRegister DeviceConfig (DWHCI_DEV_CFG);
-			DeviceConfig.Read ();
-			u32 nCount =    (DeviceConfig.Get () & DWHCI_DEV_CFG_EP_MISMATCH_COUNT__MASK)
-				     >> DWHCI_DEV_CFG_EP_MISMATCH_COUNT__SHIFT;
-			nCount++;
-			DeviceConfig.And (~DWHCI_DEV_CFG_EP_MISMATCH_COUNT__MASK);
-			DeviceConfig.Or (nCount << DWHCI_DEV_CFG_EP_MISMATCH_COUNT__SHIFT);
-			DeviceConfig.Write ();
-		}
+				// Update EP mismatch count
+				CDWHCIRegister DeviceConfig (DWHCI_DEV_CFG);
+				DeviceConfig.Read ();
+				u32 nCount =    (DeviceConfig.Get () & DWHCI_DEV_CFG_EP_MISMATCH_COUNT__MASK)
+					     >> DWHCI_DEV_CFG_EP_MISMATCH_COUNT__SHIFT;
+				nCount++;
+				DeviceConfig.And (~DWHCI_DEV_CFG_EP_MISMATCH_COUNT__MASK);
+				DeviceConfig.Or (nCount << DWHCI_DEV_CFG_EP_MISMATCH_COUNT__SHIFT);
+				DeviceConfig.Write ();
+			}
 
-		EPCtrl.Write ();
+			EPCtrl.Write ();
+		}
+		else
+		{
+			// Endpoint not yet activated - just reset data toggle to DATA0
+			EPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D0);
+			EPCtrl.Write ();
+			// Don't set ACTIVE_EP here - will be done during OnActivate()
+			// after SET_CONFIGURATION
+			return;  // Skip the rest of endpoint setup
+		}
 	}
 
 	// Enable EP interrupt
 	CDWHCIRegister AllEPsIntMask (DWHCI_DEV_ALL_EPS_INT_MASK);
+#ifdef USB_GADGET_DEBUG
+	u32 nOldMask = AllEPsIntMask.Read ();
+#else
 	AllEPsIntMask.Read ();
+#endif
 	switch (m_Direction)
 	{
 	case DirectionInOut:
@@ -176,6 +192,9 @@ void CDWUSBGadgetEndpoint::OnUSBReset (void)
 		break;
 	}
 	AllEPsIntMask.Write ();
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("EP%u OnUSBReset: mask 0x%08X -> 0x%08X", m_nEP, nOldMask, AllEPsIntMask.Read());
+#endif
 }
 
 void CDWUSBGadgetEndpoint::BeginTransfer (TTransferMode Mode, void *pBuffer, size_t nLength)
@@ -224,21 +243,46 @@ void CDWUSBGadgetEndpoint::BeginTransfer (TTransferMode Mode, void *pBuffer, siz
 		InEPCtrl.Or (s_NextEPSeq[m_nEP] << DWHCI_DEV_IN_EP_CTRL_NEXT_EP__SHIFT);
 		InEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_ENABLE);
 		InEPCtrl.Or (DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+	
+		// For EP0 zero-length STATUS stage, use DATA1 PID
+		if (m_nEP == 0 && nLength == 0) {
+			InEPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D1);
+		}
+	
 		InEPCtrl.Write ();
+		DataMemBarrier(); // Ensure write completes before hardware processes
 	}
-	else
+	else if (Mode == TransferSetupOut)
 	{
-		CDWHCIRegister OutEPXferSize (DWHCI_DEV_OUT_EP_XFER_SIZ (m_nEP), 0);
+		// EP0 SETUP transfer - EP0 OUT was already initialized during HandleUSBReset()
+		// We only need to update DMA address, transfer size already set during init
+		assert (m_nEP == 0);
+		assert (nLength == sizeof (TSetupData));
 
-		if (Mode == TransferSetupOut)
-		{
-			assert (m_nEP == 0);
-			assert (nLength == sizeof (TSetupData));
+#ifdef USB_GADGET_DEBUG
+		LOGDBG ("EP0 SETUP transfer: updating DMA address only (EP already initialized)");
+#endif
 
-			OutEPXferSize.Or (   nPacketCount
-					  << DWHCI_DEV_EP0_XFER_SIZ_SETUP_PKT_CNT__SHIFT);
-		}
+		// Update DMA address for SETUP packet
+		CDWHCIRegister OutEPDMAAddress (DWHCI_DEV_OUT_EP_DMA_ADDR (0),
+						BUS_ADDRESS ((uintptr) pBuffer));
+		OutEPDMAAddress.Write ();
+		DataMemBarrier ();
+
+		// EP0 OUT is already enabled and armed from HandleUSBReset()
+		// Don't touch DOEPCTL0 - it's already in the correct state
 
+#ifdef USB_GADGET_DEBUG
+		// Verify EP0 state
+		CDWHCIRegister OutEP0Ctrl (DWHCI_DEV_OUT_EP_CTRL (0));
+		u32 nCtrl = OutEP0Ctrl.Read ();
+		LOGDBG ("EP0 SETUP: DOEPCTL0=0x%08X (should have EP_ENABLE+ACTIVE_EP)", nCtrl);
+#endif
+	}
+	else
+	{
+		// TransferDataOut for non-SETUP transfers
+		CDWHCIRegister OutEPXferSize (DWHCI_DEV_OUT_EP_XFER_SIZ (m_nEP), 0);
 		OutEPXferSize.Or (nPacketCount << DWHCI_DEV_EP_XFER_SIZ_PKT_CNT__SHIFT);
 		OutEPXferSize.Or (nLength << DWHCI_DEV_EP_XFER_SIZ_XFER_SIZ__SHIFT);
 		OutEPXferSize.Write ();
@@ -247,12 +291,67 @@ void CDWUSBGadgetEndpoint::BeginTransfer (TTransferMode Mode, void *pBuffer, siz
 						BUS_ADDRESS ((uintptr) pBuffer));
 		OutEPDMAAddress.Write ();
 
+		CDWHCIRegister OutEPCtrl (DWHCI_DEV_OUT_EP_CTRL (m_nEP), 0);
+		u32 nCtrlBefore = OutEPCtrl.Read ();
+		
+		// Only set EP_ENABLE if not already enabled
+		if (!(nCtrlBefore & DWHCI_DEV_EP_CTRL_EP_ENABLE)) {
+			OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_ENABLE);
+		}
+		
+		// Set ACTIVE_EP if not already set
+		if (!(nCtrlBefore & DWHCI_DEV_EP_CTRL_ACTIVE_EP)) {
+			OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_ACTIVE_EP);
+		}
+		
+		// Always clear NAK to start/continue transfer
+		OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+		
+		// For EP0, ensure data toggle for control endpoint operation
+		if (m_nEP == 0) {
+			OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_SETDPID_D0);
+		}
+		
+#ifdef USB_GADGET_DEBUG
+		u32 nCtrlValue = OutEPCtrl.Get();
+		LOGDBG ("EP%u BeginTransfer OUT: before=0x%08X, writing=0x%08X", 
+			m_nEP, nCtrlBefore, nCtrlValue);
+#endif
+		
+		OutEPCtrl.Write ();
+		DataMemBarrier(); // Ensure write completes before hardware processes
+		
+#ifdef USB_GADGET_DEBUG
+		DataSyncBarrier();
+		u32 nCtrlAfter = OutEPCtrl.Read();
+		LOGDBG ("EP%u BeginTransfer OUT: after readback=0x%08X, mode=%d, len=%u",
+			m_nEP, nCtrlAfter, Mode, nLength);
+#endif
+	}
+}
+
+void CDWUSBGadgetEndpoint::CancelTransfer (void)
+{
+	if (m_TransferMode == TransferDataIn)
+	{
+		CDWHCIRegister InEPCtrl (DWHCI_DEV_IN_EP_CTRL (m_nEP), 0);
+		InEPCtrl.Read ();
+		InEPCtrl.And (~DWHCI_DEV_EP_CTRL_EP_ENABLE);
+		InEPCtrl.And (~DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+		InEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_DISABLE);
+		InEPCtrl.Write ();
+	}
+	else if (m_TransferMode != TransferUnknown)
+	{
 		CDWHCIRegister OutEPCtrl (DWHCI_DEV_OUT_EP_CTRL (m_nEP));
 		OutEPCtrl.Read ();
-		OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_ENABLE);
-		OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+		OutEPCtrl.And (~DWHCI_DEV_EP_CTRL_EP_ENABLE);
+		OutEPCtrl.And (~DWHCI_DEV_EP_CTRL_CLEAR_NAK);
+		OutEPCtrl.Or (DWHCI_DEV_EP_CTRL_EP_DISABLE);
 		OutEPCtrl.Write ();
 	}
+
+	InitTransfer ();
 }
 
 size_t CDWUSBGadgetEndpoint::FinishTransfer (void)
@@ -275,7 +374,12 @@ size_t CDWUSBGadgetEndpoint::FinishTransfer (void)
 
 	if (nXferSize)
 	{
-		debug_hexdump (m_pTransferBuffer, nXferSize, From);
+		size_t nDumpSize = nXferSize > 16 ? 16 : nXferSize;  // Max 16 bytes
+		debug_hexdump (m_pTransferBuffer, nDumpSize, From);
+		if (nXferSize > 16)
+		{
+			LOGDBG ("... (%u more bytes not shown)", nXferSize - 16);
+		}
 	}
 #endif
 
@@ -301,6 +405,13 @@ void CDWUSBGadgetEndpoint::Stall (boolean bIn)
 	EPCtrl.Or (DWHCI_DEV_EP_CTRL_STALL);
 	EPCtrl.Or (DWHCI_DEV_EP_CTRL_CLEAR_NAK);
 	EPCtrl.Write ();
+
+	// Flush TX FIFO for IN endpoints (Linux kernel pattern)
+	if (bIn)
+	{
+		assert (m_pGadget);
+		m_pGadget->FlushTxFIFO (m_nEP);
+	}
 }
 
 void CDWUSBGadgetEndpoint::OnControlMessage (void)
@@ -313,16 +424,22 @@ void CDWUSBGadgetEndpoint::HandleOutInterrupt (void)
 	CDWHCIRegister OutEPCommonIntMask (DWHCI_DEV_OUT_EP_COMMON_INT_MASK);
 	CDWHCIRegister OutEPInt (DWHCI_DEV_OUT_EP_INT (m_nEP));
 	OutEPCommonIntMask.Read ();
-	OutEPInt.Read ();
+	u32 nIntStatus = OutEPInt.Read ();
 	OutEPInt.And (OutEPCommonIntMask.Get ());
 
 #ifdef USB_GADGET_DEBUG
-	LOGDBG ("EP%u: Interrupt status is 0x%08X", m_nEP, OutEPInt.Get ());
+	LOGDBG ("EP%u OUT: raw_int=0x%08X mask=0x%08X filtered=0x%08X", 
+		m_nEP, nIntStatus, OutEPCommonIntMask.Get(), OutEPInt.Get());
 #endif
 
 	if (OutEPInt.Get () & DWHCI_DEV_OUT_EP_INT_SETUP_DONE)
 	{
 		assert (m_nEP == 0);
+		
+#ifdef USB_GADGET_DEBUG
+		LOGDBG ("EP0: SETUP_DONE interrupt");
+#endif
+		
 		CDWHCIRegister OutEPIntAck (DWHCI_DEV_OUT_EP_INT (m_nEP));
 		OutEPIntAck.Set (DWHCI_DEV_OUT_EP_INT_SETUP_DONE);
 		OutEPIntAck.Write ();
@@ -340,6 +457,10 @@ void CDWUSBGadgetEndpoint::HandleOutInterrupt (void)
 
 	if (OutEPInt.Get () & DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE)
 	{
+#ifdef USB_GADGET_DEBUG
+		LOGDBG ("EP%u: XFER_COMPLETE", m_nEP);
+#endif
+		
 		CDWHCIRegister OutEPIntAck (DWHCI_DEV_OUT_EP_INT (m_nEP));
 		OutEPIntAck.Set (DWHCI_DEV_OUT_EP_INT_XFER_COMPLETE);
 		OutEPIntAck.Write ();
@@ -365,15 +486,20 @@ void CDWUSBGadgetEndpoint::HandleInInterrupt (void)
 	CDWHCIRegister InEPCommonIntMask (DWHCI_DEV_IN_EP_COMMON_INT_MASK);
 	CDWHCIRegister InEPInt (DWHCI_DEV_IN_EP_INT (m_nEP));
 	InEPCommonIntMask.Read ();
-	InEPInt.Read ();
+	u32 nIntStatus = InEPInt.Read ();
 	InEPInt.And (InEPCommonIntMask.Get ());
 
 #ifdef USB_GADGET_DEBUG
-	LOGDBG ("EP%u: Interrupt status is 0x%08X", m_nEP, InEPInt.Get ());
+	LOGDBG ("EP%u IN: raw_int=0x%08X mask=0x%08X filtered=0x%08X",
+		m_nEP, nIntStatus, InEPCommonIntMask.Get(), InEPInt.Get());
 #endif
 
 	if (InEPInt.Get () & DWHCI_DEV_IN_EP_INT_XFER_COMPLETE)
 	{
+#ifdef USB_GADGET_DEBUG
+		LOGDBG ("EP%u: XFER_COMPLETE", m_nEP);
+#endif
+		
 		CDWHCIRegister InEPIntAck (DWHCI_DEV_IN_EP_INT (m_nEP));
 		InEPIntAck.Set (DWHCI_DEV_IN_EP_INT_XFER_COMPLETE);
 		InEPIntAck.Write ();
@@ -404,4 +530,4 @@ void CDWUSBGadgetEndpoint::HandleUSBReset (void)
 	memset (s_NextEPSeq, 0xFF, sizeof s_NextEPSeq);
 	s_NextEPSeq[0] = 0;
 	s_uchFirstInNextEPSeq = 0;
-}
+}
\ No newline at end of file
diff --git a/lib/usb/gadget/dwusbgadgetendpoint0.cpp b/lib/usb/gadget/dwusbgadgetendpoint0.cpp
index 3a70f3d3..8f5ebd3c 100644
--- a/lib/usb/gadget/dwusbgadgetendpoint0.cpp
+++ b/lib/usb/gadget/dwusbgadgetendpoint0.cpp
@@ -2,7 +2,7 @@
 // dwusbgadgetendpoint0.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -21,8 +21,13 @@
 #include <circle/usb/gadget/dwusbgadget.h>
 #include <circle/usb/dwhci.h>
 #include <circle/util.h>
+#include <circle/logger.h>
 #include <assert.h>
 
+#ifdef USB_GADGET_DEBUG
+	static const char From[] = "ep0";
+#endif
+
 CDWUSBGadgetEndpoint0::CDWUSBGadgetEndpoint0 (size_t nMaxPacketSize, CDWUSBGadget *pGadget)
 :	CDWUSBGadgetEndpoint (nMaxPacketSize, pGadget),
 	m_State (StateDisconnect)
@@ -35,9 +40,36 @@ CDWUSBGadgetEndpoint0::~CDWUSBGadgetEndpoint0 (void)
 
 void CDWUSBGadgetEndpoint0::OnActivate (void)
 {
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("OnActivate called - arming EP0 for SETUP");
+	
+	// Verify EP0 state before arming
+	CDWHCIRegister OutEP0Ctrl (DWHCI_DEV_OUT_EP_CTRL (0));
+	CDWHCIRegister OutEP0XferSize (DWHCI_DEV_OUT_EP_XFER_SIZ (0));
+	CDWHCIRegister OutEP0DMA (DWHCI_DEV_OUT_EP_DMA_ADDR (0));
+	
+	LOGDBG ("Pre-activate: DOEPCTL0=0x%08X DOEPTSIZ0=0x%08X DOEPDMA0=0x%08X",
+		OutEP0Ctrl.Read(), OutEP0XferSize.Read(), OutEP0DMA.Read());
+#endif
+	
 	m_State = StateIdle;
 
 	BeginTransfer (TransferSetupOut, m_OutBuffer, sizeof (TSetupData));
+	
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("OnActivate complete - EP0 armed for SETUP reception");
+	
+	// Verify state after arming
+	LOGDBG ("Post-activate: DOEPCTL0=0x%08X DOEPTSIZ0=0x%08X DOEPDMA0=0x%08X",
+		OutEP0Ctrl.Read(), OutEP0XferSize.Read(), OutEP0DMA.Read());
+#endif
+}
+
+void CDWUSBGadgetEndpoint0::OnDeactivate (void)
+{
+	m_State = StateDisconnect;
+
+	CancelTransfer ();
 }
 
 void CDWUSBGadgetEndpoint0::OnControlMessage (void)
@@ -46,6 +78,13 @@ void CDWUSBGadgetEndpoint0::OnControlMessage (void)
 
 	const TSetupData *pSetupData = reinterpret_cast<TSetupData *> (m_OutBuffer);
 
+#ifdef USB_GADGET_DEBUG
+	LOGDBG ("OnControlMessage: bmRequestType=0x%02x, bRequest=0x%02x, wValue=0x%04x, wLength=%u, state=%d",
+		pSetupData->bmRequestType, pSetupData->bRequest, pSetupData->wValue, 
+		pSetupData->wLength, m_State);
+	//debug_hexdump (m_OutBuffer, sizeof(TSetupData), From);
+#endif
+
 	// copy setup packet to be used in OnTransferComplete()
 	memcpy (&m_SetupData, pSetupData, sizeof m_SetupData);
 
@@ -141,11 +180,21 @@ void CDWUSBGadgetEndpoint0::OnControlMessage (void)
 		switch (pSetupData->bRequest)
 		{
 		case SET_ADDRESS:
-			m_pGadget->SetDeviceAddress (pSetupData->wValue & 0xFF);
-
+			// Don't set address yet - must respond to STATUS stage on address 0
+			// Address will be set after STATUS stage completes (USB spec requirement)
+#ifdef USB_GADGET_DEBUG
+			LOGDBG ("SET_ADDRESS(%u) - preparing STATUS IN (state=%d)", 
+				pSetupData->wValue & 0xFF, m_State);
+#endif
 			m_State = StateInStatusPhase;
 
+#ifdef USB_GADGET_DEBUG
+			LOGDBG ("Calling BeginTransfer for STATUS IN ZLP");
+#endif
 			BeginTransfer (TransferDataIn, nullptr, 0);
+#ifdef USB_GADGET_DEBUG
+			LOGDBG ("BeginTransfer returned");
+#endif
 			break;
 
 		case SET_CONFIGURATION:
@@ -166,15 +215,25 @@ void CDWUSBGadgetEndpoint0::OnControlMessage (void)
 		default:
 			if (pSetupData->wLength)
 			{
-				m_State = StateOutDataPhase;
-
 				// EP0 can transfer only up to 127 bytes at once. Therefore
 				// we split greater transfers into multiple transfers, with
 				// up to max. packet size each.
-				assert (pSetupData->wLength <= sizeof m_OutBuffer);
+
+				if (pSetupData->wLength > sizeof m_OutBuffer)
+				{
+					Stall (FALSE);
+
+					BeginTransfer (TransferSetupOut, m_OutBuffer,
+						       sizeof (TSetupData));
+
+					return;
+				}
+
 				m_nBytesLeft = pSetupData->wLength;
 				m_pBufPtr = m_OutBuffer;
 
+				m_State = StateOutDataPhase;
+
 				BeginTransfer (TransferDataOut, m_pBufPtr,
 						 m_nBytesLeft <= m_nMaxPacketSize
 					       ? m_nBytesLeft : m_nMaxPacketSize);
@@ -231,6 +290,16 @@ void CDWUSBGadgetEndpoint0::OnTransferComplete (boolean bIn, size_t nLength)
 		break;
 
 	case StateInStatusPhase:
+		// Apply SET_ADDRESS after STATUS stage completes (USB spec requirement)
+		if (m_SetupData.bRequest == SET_ADDRESS)
+		{
+#ifdef USB_GADGET_DEBUG
+			LOGDBG ("STATUS IN complete - now setting address %u", m_SetupData.wValue & 0xFF);
+#endif
+			assert (m_pGadget);
+			m_pGadget->SetDeviceAddress (m_SetupData.wValue & 0xFF);
+		}
+
 		assert (m_pGadget);
 		if (   m_SetupData.bmRequestType & (REQUEST_CLASS | REQUEST_VENDOR)
 		    && m_pGadget->OnClassOrVendorRequest (&m_SetupData, m_OutBuffer) < 0)
@@ -248,4 +317,4 @@ void CDWUSBGadgetEndpoint0::OnTransferComplete (boolean bIn, size_t nLength)
 		assert (0);
 		break;
 	}
-}
+}
\ No newline at end of file
diff --git a/lib/usb/gadget/usbcdcgadget.cpp b/lib/usb/gadget/usbcdcgadget.cpp
index 26a08b34..3bd6db3e 100644
--- a/lib/usb/gadget/usbcdcgadget.cpp
+++ b/lib/usb/gadget/usbcdcgadget.cpp
@@ -21,10 +21,9 @@
 //
 #include <circle/usb/gadget/usbcdcgadget.h>
 #include <circle/usb/gadget/usbcdcgadgetendpoint.h>
-#include <circle/sysconfig.h>
 #include <assert.h>
 
-const TUSBDeviceDescriptor CUSBCDCGadget::s_DeviceDescriptor =
+TUSBDeviceDescriptor CUSBCDCGadget::s_DeviceDescriptor =
 {
 	sizeof (TUSBDeviceDescriptor),
 	DESCRIPTOR_DEVICE,
@@ -131,11 +130,13 @@ const char *const CUSBCDCGadget::s_StringDescriptor[] =
 	"CDC Gadget"
 };
 
-CUSBCDCGadget::CUSBCDCGadget (CInterruptSystem *pInterruptSystem)
+CUSBCDCGadget::CUSBCDCGadget (CInterruptSystem *pInterruptSystem, u16 usVendorID, u16 usProductID)
 :	CDWUSBGadget (pInterruptSystem, HighSpeed),
 	m_pInterface (nullptr),
 	m_pEP {nullptr, nullptr, nullptr, nullptr}
 {
+	s_DeviceDescriptor.idVendor = usVendorID;
+	s_DeviceDescriptor.idProduct = usProductID;
 }
 
 CUSBCDCGadget::~CUSBCDCGadget (void)
diff --git a/lib/usb/gadget/usbcdcgadgetendpoint.cpp b/lib/usb/gadget/usbcdcgadgetendpoint.cpp
index e0b3186a..813198b6 100644
--- a/lib/usb/gadget/usbcdcgadgetendpoint.cpp
+++ b/lib/usb/gadget/usbcdcgadgetendpoint.cpp
@@ -4,7 +4,7 @@
 // This file by Sebastien Nicolas <seba1978@gmx.de>
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -70,6 +70,14 @@ void CUSBCDCGadgetEndpoint::OnActivate (void)
 	}
 }
 
+void CUSBCDCGadgetEndpoint::OnDeactivate (void)
+{
+	if (GetDirection () == DirectionOut)
+	{
+		CancelTransfer ();
+	}
+}
+
 void CUSBCDCGadgetEndpoint::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	if (!bIn)
diff --git a/lib/usb/gadget/usbmidigadget.cpp b/lib/usb/gadget/usbmidigadget.cpp
index d0aeb133..479e1e99 100644
--- a/lib/usb/gadget/usbmidigadget.cpp
+++ b/lib/usb/gadget/usbmidigadget.cpp
@@ -19,10 +19,9 @@
 //
 #include <circle/usb/gadget/usbmidigadget.h>
 #include <circle/usb/gadget/usbmidigadgetendpoint.h>
-#include <circle/sysconfig.h>
 #include <assert.h>
 
-const TUSBDeviceDescriptor CUSBMIDIGadget::s_DeviceDescriptor =
+TUSBDeviceDescriptor CUSBMIDIGadget::s_DeviceDescriptor =
 {
 	sizeof (TUSBDeviceDescriptor),
 	DESCRIPTOR_DEVICE,
@@ -166,11 +165,13 @@ const char *const CUSBMIDIGadget::s_StringDescriptor[] =
 	"MIDI Gadget"
 };
 
-CUSBMIDIGadget::CUSBMIDIGadget (CInterruptSystem *pInterruptSystem)
+CUSBMIDIGadget::CUSBMIDIGadget (CInterruptSystem *pInterruptSystem, u16 usVendorID, u16 usProductID)
 :	CDWUSBGadget (pInterruptSystem, HighSpeed),
 	m_pInterface (nullptr),
 	m_pEP {nullptr, nullptr, nullptr}
 {
+	s_DeviceDescriptor.idVendor = usVendorID;
+	s_DeviceDescriptor.idProduct = usProductID;
 }
 
 CUSBMIDIGadget::~CUSBMIDIGadget (void)
diff --git a/lib/usb/gadget/usbmidigadgetendpoint.cpp b/lib/usb/gadget/usbmidigadgetendpoint.cpp
index 040df576..f3a17711 100644
--- a/lib/usb/gadget/usbmidigadgetendpoint.cpp
+++ b/lib/usb/gadget/usbmidigadgetendpoint.cpp
@@ -2,7 +2,7 @@
 // usbmidigadgetendpoint.cpp
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -69,6 +69,14 @@ void CUSBMIDIGadgetEndpoint::OnActivate (void)
 	}
 }
 
+void CUSBMIDIGadgetEndpoint::OnDeactivate (void)
+{
+	if (GetDirection () == DirectionOut)
+	{
+		CancelTransfer ();
+	}
+}
+
 void CUSBMIDIGadgetEndpoint::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	if (!bIn)
diff --git a/lib/usb/gadget/usbmsdgadget.cpp b/lib/usb/gadget/usbmsdgadget.cpp
index 6ec80662..42dccfc8 100644
--- a/lib/usb/gadget/usbmsdgadget.cpp
+++ b/lib/usb/gadget/usbmsdgadget.cpp
@@ -4,7 +4,7 @@
 // USB Mass Storage Gadget by Mike Messinides
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -31,7 +31,7 @@
 #define MLOGERR(From,...)		CLogger::Get ()->Write (From, LogError,__VA_ARGS__)
 #define DEFAULT_BLOCKS 16000
 
-const TUSBDeviceDescriptor CUSBMSDGadget::s_DeviceDescriptor =
+TUSBDeviceDescriptor CUSBMSDGadget::s_DeviceDescriptor =
 {
 	sizeof (TUSBDeviceDescriptor),
 	DESCRIPTOR_DEVICE,
@@ -93,11 +93,14 @@ const char *const CUSBMSDGadget::s_StringDescriptor[] =
 	"Mass Storage Gadget"
 };
 
-CUSBMSDGadget::CUSBMSDGadget (CInterruptSystem *pInterruptSystem, CDevice *pDevice)
+CUSBMSDGadget::CUSBMSDGadget (CInterruptSystem *pInterruptSystem, CDevice *pDevice,
+			      u16 usVendorID, u16 usProductID)
 :	CDWUSBGadget (pInterruptSystem, HighSpeed),
 	m_pDevice (pDevice),
 	m_pEP {nullptr, nullptr, nullptr}
 {
+	s_DeviceDescriptor.idVendor = usVendorID;
+	s_DeviceDescriptor.idProduct = usProductID;
 	if(pDevice)SetDevice(pDevice);
 }
 
@@ -252,6 +255,38 @@ int CUSBMSDGadget::OnClassOrVendorRequest (const TSetupData *pSetupData, u8 *pDa
 	return -1;
 }
 
+void CUSBMSDGadget::OnNegotiatedSpeed (TDeviceSpeed Speed)
+{
+	if (Speed == FullSpeed)
+	{
+		MLOGNOTE ("OnNegotiatedSpeed", "FullSpeed");
+
+		if (m_pEP[EPIn])
+		{
+			m_pEP[EPIn]->SetMaxPacketSize (64);
+		}
+
+		if (m_pEP[EPOut])
+		{
+			m_pEP[EPOut]->SetMaxPacketSize (64);
+		}
+	}
+	else
+	{
+		MLOGNOTE ("OnNegotiatedSpeed", "HighSpeed");
+
+		if (m_pEP[EPIn])
+		{
+			m_pEP[EPIn]->SetMaxPacketSize (512);
+		}
+
+		if (m_pEP[EPOut])
+		{
+			m_pEP[EPOut]->SetMaxPacketSize (512);
+		}
+	}
+}
+
 void CUSBMSDGadget::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	MLOGDEBUG("OnXferComplete", "state = %i, dir = %s, len=%i ",m_nState,bIn?"IN":"OUT",nLength);
@@ -371,6 +406,14 @@ void CUSBMSDGadget::OnActivate()
 	m_pEP[EPOut]->BeginTransfer(CUSBMSDGadgetEndpoint::TransferCBWOut,m_OutBuffer,SIZE_CBW);
 }
 
+void CUSBMSDGadget::OnDeactivate()
+{
+	MLOGNOTE("MSD OnDeactivate", "state = %i",m_nState);
+	m_MSDReady=false;
+	m_nState=TMSDState::Init;
+	m_pEP[EPOut]->CancelTransfer();
+}
+
 void CUSBMSDGadget::SendCSW()
 {
 	memcpy(&m_InBuffer,&m_CSW,SIZE_CSW);
diff --git a/lib/usb/gadget/usbmsdgadgetendpoint.cpp b/lib/usb/gadget/usbmsdgadgetendpoint.cpp
index 222d4de9..78d111b1 100644
--- a/lib/usb/gadget/usbmsdgadgetendpoint.cpp
+++ b/lib/usb/gadget/usbmsdgadgetendpoint.cpp
@@ -4,7 +4,7 @@
 // USB Mass Storage Gadget by Mike Messinides
 //
 // Circle - A C++ bare metal environment for Raspberry Pi
-// Copyright (C) 2023-2024  R. Stange <rsta2@o2online.de>
+// Copyright (C) 2023-2025  R. Stange <rsta2@gmx.net>
 //
 // This program is free software: you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
@@ -50,6 +50,14 @@ void CUSBMSDGadgetEndpoint::OnActivate (void)
 	}
 }
 
+void CUSBMSDGadgetEndpoint::OnDeactivate (void)
+{
+	if (GetDirection () == DirectionOut)
+	{
+		m_pGadget->OnDeactivate();
+	}
+}
+
 void CUSBMSDGadgetEndpoint::OnTransferComplete (boolean bIn, size_t nLength)
 {
 	MLOGNOTE("MSDEndpoint","Transfer complete nlen= %i",nLength);
@@ -77,6 +85,11 @@ void CUSBMSDGadgetEndpoint::BeginTransfer (TMSDTransferMode Mode, void *pBuffer,
 	}
 }
 
+void CUSBMSDGadgetEndpoint::CancelTransfer (void)
+{
+	CDWUSBGadgetEndpoint::CancelTransfer();
+}
+
 void CUSBMSDGadgetEndpoint::StallRequest(boolean bIn)
 {
 	CDWUSBGadgetEndpoint::Stall(bIn);
